(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* :Title: diffEqClass.m-- A package for differential equations *)
(* :Context: diffEqClass` *)
(* :Author: Michael Rogers *)
(* :Summary: Provides support for teaching and learning diff. eq. *)
(* :Copyright: \[Copyright]2019 by Michael Rogers *)
(* :Package Version: 0.2.22 *)
(* :Mathematica Version: 12.0 *)
(* :History:
	0.2 September 2019 
	0.1 August 2019 
	Started as math212`, a package for Diff. Eq. course
*)
(* :Keywords: differential equations, education *)
(* :Sources:
    TBD
*)
(* :Warnings: None yet *)
(* :Limitations: All yet *)
(* :Discussion: TBD *)
(* :Requirements: None *)
(* :Examples: TBD *)


BeginPackage["diffEqClass`"];
Unprotect[diffEq];


(* ::Input::Initialization:: *)
$diffEqClass=<|
"Keys"->{ (* canonical order *)
"title",
"de",
"dependentVars",
"independentVars",
"completeDependentVars",
"indexedVars",
"bcs",
"domain",
"parameters",
"defaultParameterValues", (* list of substitution rules *)
"firstorder",
"exact",
"numerical",
"ndstate", (* TBD: to allow resetting IC/BC ??? *)
"series",
"class",
"order",
"type",
"singularities"
},
"SetupKeys"->{ (* Hmm... ??? *)
"de",
"bcs",
"domain",
"dependentVars",
"independentVars",
"order"
},
"Methods"->{ (* Hmm... ??? *)
"help",
"plot",
(*"phasefield",
"phaseportrait",*)
"contact",
"particular"
}
|>;


(* ::Input::Initialization:: *)
ClearAll[
diffEq, (* the ODE object *)
setupDiffEq,
help,about,
toImplicitSolution,
LieD,
LieDerivative,
totalD,
vectorPlot1D,
plotSeparatrices,
stabilityTrajectories,
diffEqDemo
];
PrependTo[$ContextPath,"diffEqClass`utilities`"];


(* ::Input::Initialization:: *)
Begin["`utilities`"];


(* ::Input::Initialization:: *)
ClearAll[
iDiffEq,
checkArgs,
checkSol,
getKey,
needsBCs,
defaultValue,
getCommand,
getInactiveSolverCode,(* Hold vs Inactive? *)
getHeldSolverCode,(* Hold vs Inactive? *)
getDomain,
getParameters,
getDefaultProblemType,
getVectorField,
deReduce,
plotDE, (* deprecated ??? *)
getInactivePlotCode,(* Hold vs Inactive? *)
getHeldPlotCode,(* Hold vs Inactive? *)
getPlotter,
setupNumerical,
updateNumerical,
stripArgs, (* take args off dependent variables *)
cullArgs, (* get args of dependent variables *)
addArgs, (* add args to dependent variables *)
functionalToAlgebraic,(* convert ODE to alg form: x[t]\[Rule]x[0], x'[t]\[Rule]x[1], etc. *)
algebraicToFunctional,
varsToIndexedVars,(* change x, x',... to x[0], x[1],... *)
indexedVarsToVars,
getHelp,
odeQ, (* properties & classifications *)
pdeQ,
linearQ,
autonomousQ,
ivpQ,
bvpQ,
particularQ, (* base problem asks for a particular solution (ivp/bvp) *)
implicitSolutionQ,
realContinuousQ,
betweenQ,
coefficients,
singularities,
equilibria,
getStoppingEvents,
findIMIE, (* find integer matrices with integer eigenvalues *)
TBD,db (* throws TBD error, debug print *)
];


(* ::Input::Initialization:: *)
End[]; (* "`utilities`" *)


(* ::Input::Initialization:: *)
Begin["`diffEqDump`"];


(* getCommand[]
getCommand[de, cmd, args]
parses plot and solving commands for (de:diffEq[asc_])[cmd_, args_]
code is distributed in the Solving and Plotting sections
other simple commands either  get intercepted before passed or returned
returns $Failed if unsuccessful ???

iDiffEq[]
iDiffEq[de, cmd, args]
carries out parse and solve commands
*)


(* ::Input::Initialization:: *)
(*Clear[
getCommand, (* parse commands to diffEq[a] *)
iDiffEq (* execute commands to diffEq[a] *)
];*)


(* ::Input::Initialization:: *)
End[]; (* "`diffEqDump`" *)


(* ::Input::Initialization:: *)
Begin["`diffEqDump`"];


(* ::Input::Initialization:: *)
(* utilities`getKey
*   getKey[de, key, opts]
*   gets key ("domain") from options, then from de (asc)
*   as internal, assume arguments are of proper typef
 *)
getKey[de:diffEq[asc_],key_,opts_]:=Module[{(*deOpts,*)trange},
(*deOpts=Association@FilterRules[opts,{key}];*)
trange=Lookup[opts,key,Lookup[asc,key,defaultValue[de,key]]]
];
defaultValue[de:diffEq[asc_],"domain"]:={{0,1}};(* BE SMARTER: Check BCS ??? *)
defaultValue[de:diffEq[asc_],"asymptoticOrder"]:=1+First@Flatten@getKey[de,"order",{"order"->{1}}];defaultValue[de:diffEq[asc_],"defaultParameterValues"]:=Lookup[asc,"defaultParameterValues",{}];call:defaultValue[de:diffEq[asc_],key_]:=TBD[HoldForm@call];

needsBCs[de:diffEq[asc_],opts_]:=Module[{bcs},
bcs=getKey[de,"bcs",opts];
If[bcs===Automatic||bcs=={}||MissingQ[bcs],
bcs=MapThread[#[First@#2]==Last@#2&,
{Flatten@Lookup[asc,"completeDependentVars"],
PadRight[{{0,1}},{Length@Flatten@Lookup[asc,"completeDependentVars"],2}]}];
Message[diffEq::NoBCS,bcs];
];
bcs
];


(* ::Input::Initialization:: *)
(* utilities`getDomain
* getDomain[de, type, ivars, opts_List]
* get domain of DE for ivars {{xa,a1,a2}, {xb,b1,b2},..}
 *)
(* ivars = Automatic handler ??? *)
diffEq::notdvar="Warning: `` is not a dependent variable of the differential equation.";
call:getDomain[de:diffEq[asc_],type:"flow"|"vector field"|"implicit",vvars_,opts_]:=
Module[{ivar,vars,xints,allvars},
ivar=Lookup[asc,"independentVars"];
allvars=Flatten@Lookup[asc,"completeDependentVars",{}];
vars=Replace[vvars,Automatic:>If[autonomousQ[de],allvars,Join[ivar,allvars]]];
xints=Values@Flatten[equilibria[de],1]/.
{}->{ConstantArray[0,Length@allvars]}; (* default, when no equilibria *)
xints=#+{-1,1}&/@MinMax/@Transpose@xints; (* in "completeDependentVars" order *)
xints=AssociationThread[allvars->PadLeft[xints,{Automatic,3},List/@allvars]];
Replace[
vars,
{
int:{_,_?NumericQ,_?NumericQ}:>int,
t:Alternatives@@ivar:>First@getDomain[de,"solution",{t},opts],
x:_Symbol|Derivative[_][_Symbol]:>(
Lookup[xints,x,
Message[diffEq::notdvar,x];{x,0,1}]
),
x_:>(
Message[diffEq::pllim,x];
$stack=HoldForm[call]->Stack[]; (* for debugging ??? *)
Throw[$Failed,diffEq]
)
},
1
]
];
getDomain[de:diffEq[asc_],type_(* any type; was "solution"|"plot"|"parametric" *),tint:{_,_,_},opts_]:={tint};getDomain[de:diffEq[asc_],type_(* any type; was "solution"|"plot"|"parametric" *),
tint:{{_,_,_}..}, (* allow pde form ??? *)
opts_]:=tint;getDomain[de:diffEq[asc_],type:"solution"|"plot"|"parametric"|"polar",ivars_,opts_]/;Length@ivars==1:=Module[{tint,trange,default=type/.{"polar"->{{0,2Pi}},_->{{0,1}}}},
trange=getKey[de,"domain",opts]/.Automatic->default; (* check sing. ??? *)
If[VectorQ@trange,
trange={trange}];
tint=MapThread[Replace[#1,{a_,b_}:>{#2,a,b}]&]@{trange,ivars}
];
call:getDomain[de:diffEq[asc_],type:"solution"|"plot"|"parametric",ivars_,opts_]/;Length@ivars>1:=( (* would PDE warning be given already ??? *) 
(*If[FreeQ[$MessageList,diffEq::PDE],Message[diffEq::PDE]];*)
TBD[HoldForm@call]); 



(* ::Input::Initialization:: *)
(* getParameters[de]
*   don't include C[k] parameters in exact sol {{sys params}, {sol params}}
*   should exclude expressions of the form F[T]
*   should include A[0], etc. in ODE, not in BCS
 *)
(*getParameters[de:diffEq[asc_]]:=Module[{syms,params},
Complement[DeleteDuplicates@Cases[Lookup[asc,{"de","bcs"}],s_Symbol/;!StringMatchQ[Context[s],"System`"|"Internal`"|"Developer`"],Infinity,Heads\[Rule]True],Flatten@Lookup[asc,{"independentVars","dependentVars"}]]
]*)
diffEq::depp="Warning: Automatic parameter `` depends on parameter ``; use \"parameters\" option.";
validVariableQ[var_]:=!NumericQ[var]&&
FreeQ[var,DirectedInfinity|Indeterminate]&&
(MemberQ[{Symbol,Subscript,K,C},Head[var]]||!AtomQ@Head[var]||Context[Evaluate@Head[var]]=!="System`")&&
If[Head@Head[var]===Symbol,
!MemberQ[Attributes[Evaluate@Head[var]],NumericFunction],validVariableQ[Head[var]]];
(*getParameters[de:diffEq[asc_]]:=Module[{syms,params},
syms=Flatten@{Lookup[asc,"independentVars"],Lookup[asc,"dependentVars"]};
params=DeleteCases[
DeleteDuplicates@Cases[
{Lookup[asc,"de"],Lookup[asc,"bcs"]},
_?validVariableQ,
Infinity],
_?(!FreeQ[#,Alternatives@@syms]&)];
(*params;*)
If[Head[diffEq::depp]=!=$Off,
Do[If[s1=!=s2 &&!FreeQ[s1,s2],
Message[diffEq::depp,s1,s2] (* warning but not treated as an error *)
],
{s1,params},{s2,params}]
];
Flatten@params
];*)
getParameters[de:diffEq[asc_]]:=getParameters[
{Lookup[asc,"de"],Lookup[asc,"bcs"]},
Flatten@{Lookup[asc,"independentVars"],Lookup[asc,"dependentVars"]}
];
getParameters[eqns_,syms_]:=Module[{params},
params=DeleteCases[
DeleteDuplicates@Cases[
eqns,
_?validVariableQ,
Infinity],
_?(!FreeQ[#,Alternatives@@syms]&)];
(*params;*)
If[Head[diffEq::depp]=!=$Off,
Do[If[s1=!=s2 &&!FreeQ[s1,s2],
Message[diffEq::depp,s1,s2] (* warning but not treated as an error *)
],
{s1,params},{s2,params}]
];
Flatten@params
];

(* getParameterValues[de,opts]
*   include C[k] parameters in exact sol {{sys params}, {sol params}}
*   should exclude expressions of the form F[T]
*   should include A[0], etc. in ODE, not in BCS
 *)
getParameterValues[de:diffEq[asc_],opts_]:=Module[{pvals},
pvals=Lookup[opts,"parameterValues",getKey[de,"defaultParameterValues",opts]];
pvals=pvals/.eq_Equal:>psolve[eq];
If[MatchQ[pvals,{___Rule}],
pvals,
$Failed]
];
(* psolve solve for parameter
* enforce simple equation with unique solution
 *)
diffEq::UniqueVal="Error: equation `` for parameter does not have a unique solution.";
diffEq::BadP="Error: equation `` for parameter could not be solved.";
psolve[eq_]:=With[{sol=Solve[eq]}, (* Check[] sol, warn about eq ??? *)
Switch[sol,
_Solve
,Message[diffEq::BadP,eq]
; $Failed,
{{_Rule}},sol[[1,1]], (* success *)
{}|{{}}|_List?(Length[#]>1&)
,Message[diffEq::UniqueVal,eq]
;$Failed,
_
,Message[diffEq::CantHappen,psolve,Row[{eq, " produced solution ",sol}]]
]];


(* ::Input::Initialization:: *)
(* utilities`stripArgs - strip args of functions ff *)
stripArgs[expr_,ff_]:=expr/.{(f:Alternatives@@ff)[__]:>f,(d_Derivative)[f:Alternatives@@ff][__]:>d@f};
stripArgs[ff_][expr_]:=stripArgs[expr,ff];
(* utilities`cullArgs - cull args of functions ff: {{args f1}, {args f2},..} *)
(*   cullArgs[{y[0]\[Equal]0,y[1]\[Equal]0,z[0]\[Equal]1},{y,z}] --> {{{0},{1}},{{0}}} *)
cullArgs[expr_,ff_]:=DeleteDuplicates/@Flatten[
Last@Reap[
Cases[expr,(f:Alternatives@@ff)[args__]|_Derivative[f:Alternatives@@ff][args__]:>Sow[{args},f],Infinity],
ff
],
1];
cullArgs[ff_][expr_]:=cullArgs[expr,ff];
(* utilities`stripArgs - strip args of functions ff *)
addArgs[expr_,ff_,args_]:=expr/.{
(d_Derivative)[f:Alternatives@@ff][a__]:>d[f][a],
(f:Alternatives@@ff)[a__]:>f[a],
(d_Derivative)[f:Alternatives@@ff]:>d[f]@@args,
(f:Alternatives@@ff):>f@@args};



(* ::Input::Initialization:: *)
ivpQ::usage="ivpQ[de, opts] returns whether the problem is a initial-value problem.";
ivpQ[de:diffEq[asc_],opts_:{}]:=Module[{bcs,res=False,ics,args,dvars,alldvars},
bcs=getKey[de,"bcs",opts](*Lookup[asc,"bcs",{}]*);
If[bcs=!={},
dvars=Lookup[asc,"dependentVars"];
alldvars=Flatten@Lookup[asc,"completeDependentVars"];
args=cullArgs[bcs,dvars];
args=DeleteDuplicates[Flatten@args,Equal];
res=Length@args===1&&VectorQ[args,NumericQ];
If[res,
ics=Solve[bcs,Through[alldvars@@args]];
If[!ListQ@ics&&Length@First@ics!=Length@alldvars,
res=False;
]
]
];
res
];
bvpQ::usage="bvpQ[de, opts] returns whether the problem is a boundary-value problem.";
bvpQ[de:diffEq[asc_],opts_:{}]:=Module[{bcs,res=False,args,dvars,alldvars},
bcs=getKey[de,"bcs",opts];
alldvars=Flatten@Lookup[asc,"completeDependentVars"];
If[Length[bcs]==Length[alldvars],(* no check for independence *)
dvars=Lookup[asc,"dependentVars"];
args=cullArgs[bcs,dvars];
args=DeleteDuplicates[Flatten@args,Equal];
res=Length@args>1&&VectorQ[args,NumericQ]
];
res
];
particularQ::usage="particularQ[de, opts] returns whether the problem asks for a particular solution (i.e. is an IVP or BVP).";
particularQ[de:diffEq[asc_],opts_:{}]:=Module[{bcs,res=False,args,dvars,alldvars},
bcs=getKey[de,"bcs",opts];
alldvars=Flatten@Lookup[asc,"completeDependentVars"];
If[Length[bcs]==Length[alldvars],(* no check for independence *)
dvars=Lookup[asc,"dependentVars"];
args=cullArgs[bcs,dvars];
args=DeleteDuplicates[Flatten@args,Equal];
res=VectorQ[args,NumericQ]
];
res
];


(* ::Input::Initialization:: *)
(* implicitSolutionQ[de, sol] - return True if implicit solution *)
(* are mixed implicit/explicit possible ??? *)implicitSolutionQ[de:diffEq[asc_]]:=implicitSolutionQ[de, de["exact","particular"]]; (* was "particular" ??? *)
implicitSolutionQ[de:diffEq[asc_],_Solve|{__Solve}]:=True; 
implicitSolutionQ[___]:=False; (* error if no de argument ??? *)



(* ::Input::Initialization:: *)
(* betweenQ[interval, x0] - returns True if x0 is in the closed interval *)
(*   interval may be a pair of numbers or an iterator *)
betweenQ[{x_:0,a_?NumericQ,b_?NumericQ},x0_?NumericQ]:=TrueQ[a<=x0<=b];


(* ::Input::Initialization:: *)
(* runCode[Catch@getHeldStuff[..],"returnCode"/.{opts}]
* OR "???"
* SetAttributes[runCode, HoldFirst]
* runCode[getHeldStuff[..],"returnCode"/.{opts}]
* and runCode[] catches any Throw[]
 *)
ClearAll[runCode];
runCode[code_,holdQ_]:=Block[{diffEqClass`helpDump`lastcall},
If[TrueQ@holdQ,
code,
ReleaseHold@code
]/;FreeQ[code,getHeldSolverCode|getHeldPlotCode]
];(* includes code = $Failed *)
runCode[_,_]:=$Failed; 


(* ::Input::Initialization:: *)
(*diffEq::TBD="`` is not yet implemented.";*)
TBD[c_]:=(Message[diffEq::TBD,c];
$stack=Stack[];
Throw[$Failed,TBD]); (* Throw[] or Return[] *)
TBD[c__]:=(Message[diffEq::TBD,HoldForm@"\[LeftSkeleton]\[RightSkeleton]"[c]];
$stack=Stack[];
Throw[$Failed,TBD]); (* c = args to unknown function *)
TBD[]:=(Message[diffEq::TBD,"This functionality"];
$stack=Stack[];
Throw[$Failed,TBD]); (* Throw[] or Return[] *)
db=(Print[#1];#1)&;



(* ::Input::Initialization:: *)
End[]; (* "`diffEqDump`" *)


(* ::Input::Initialization:: *)
Begin["`diffEqDump`"];


(* ::Input::Initialization:: *)
(* saves last call to diffEq - use about[] to get info *)
(* runCode[] blocks it to keep it from being reset internally *)
call:(de:diffEq[asc_])[___]/;(
diffEqClass`helpDump`lastcall=Hold[call];
False):=Null;


(* ::Input::Initialization:: *)
(*
 * main command parser
 *)

diffEq::noPDE="Warning: Solving and plotting partial differental equations has not been implemented yet.";
(de:diffEq[asc_])[cmd_String,args:Except[_Rule]...,opts___?OptionQ]:=Module[{res,command},
res=Catch[
If[Length@Lookup[asc,"independentVars",{}]>1 (* TBD ??? *)
,Message[diffEq::noPDE]
;$Failed
,command=getCommand[{de,cmd,args},Flatten@{opts}]
;If[Head@command===getCommand
,Message[diffEq::CantHappen,getCommand,"unevaluated"]
;$Failed
,iDiffEq@@command]
],
TBD|diffEq];
$messages=$MessageList;
res/;FreeQ[res,$Failed]];


(* ::Input::Initialization:: *)
(*ClearAll[diffEq];*)(* Cleared at the top: unnecessary again ??? *)
SetAttributes[diffEq,HoldAll];
diffEq::usage="diffEq represent a differential equation; create one with setupDiffEq[].";
diffEq::meth="Error: Bad method \"``\". Use setDiffEq[de[key = value]] to change values."; (* if setDiffEq is deprecated, remove *)
(*diffEq::TBD="Error: This feature has not been implemented (yet).";*)
diffEq::TBD="Error: `` is not yet implemented.";


diffEq[asc_][msg_]:=With[{res=Lookup[asc,msg,$Failed]},res/;res=!=$Failed];


diffEq/:MakeBoxes[de:diffEq[asc_],form_]/;AssociationQ[asc]:=
Module[{above,below,ivars},
ivars=Lookup[asc,"independentVars",Automatic];
above={{BoxForm`SummaryItem[{
Which[
ivpQ@de,"IVP: ",
bvpQ@de,"BVP: ",
Length@ivars==1,"ODE: ",
Length@ivars>1,"PDE: ",
_,"???: "],
Lookup[asc,"de",None]}],SpanFromLeft}};
below={BoxForm`SummaryItem[{"BCS: ",Lookup[asc,"bcs",None]}],BoxForm`SummaryItem[{"Interval: ",Lookup[asc,"domain",Automatic]}],
BoxForm`SummaryItem[{"Dependent: ",Lookup[asc,"dependentVars",Automatic]}],
BoxForm`SummaryItem[{"Independent: ",ivars}]};
BoxForm`ArrangeSummaryBox[diffEq,de,Null,above,below,form]];

diffEq["Keys"]:=$diffEqClass["Keys"];

diffEq/:checkArgs[diffEq[asc_]]:=
(* check
*  ODE/PDE (Length@asc@independentVars)
*  ValueQ @ vars, warn  
*  ? ?
 *)
True;

(*diffEq[_][msg_String/;!MemberQ[$diffEqClass["Keys"]~Join~$diffEqClass["Methods"],msg]]:=(Message[diffEq::meth,msg];$Failed;$MessageList); (* remove $MessageList when ready *)*)
diffEq/:msg_String[de_diffEq]:=de@msg;



(* ::Input::Initialization:: *)
ClearAll[setupNumerical,updateNumerical];
setupNumerical[eqns_,y_,x_,{a_,b_},dopts:OptionsPattern[NDSolve]]:=
Module[{de,dsol,all,states,getnumericalQ,nsol,int},
all=NDSolve`ProcessEquations[eqns,y,{x,-Infinity,Infinity},dopts];
(states=Hold/@Table[Unique["state"],Length@all];
getnumericalQ=ListQ[x]&&Length[x]>1;
MapThread[
#/.Hold[s_]:>(s=#2;
If[getnumericalQ,
NDSolve`Iterate[s,a];
NDSolve`Iterate[s,b]])&,
{states,all}];
If[getnumericalQ,nsol=states/.Hold->NDSolve`ProcessSolutions];
If[NumericQ[a]&&NumericQ[b],int={x,a,b},int=Automatic];
{"numerical"->nsol,"ndstate"->states})/;ListQ[all]
];
updateNumerical[states_,int:{__?Numerical}]:=
Module[{nsol},
Map[
#/.Hold[s_]:>(NDSolve`Iterate[s,#]&/@int)&,
states];
nsol=states/.Hold->NDSolve`ProcessSolutions;
{"numerical"->nsol}
];


(* ::Input::Initialization:: *)
(* Set up/instantiate diffEq object *)
(*ClearAll[setupDiffEq];*)
SetAttributes[setupDiffEq,HoldAll];
Options[setupDiffEq]=Thread[diffEq["Keys"]->Automatic];
(* translate an NDSolve call (e.g. copied) to a diffEq object *)
(*** XXXX Rewrite with getDomain? XXX ***)
setupDiffEq[NDSolve[eqns_,y_,{x_,a_,b_},dopts:OptionsPattern[NDSolve]],opts:OptionsPattern[]]:=With[{yy=Replace[Flatten@{y},(*f_[__]*)f_@@Flatten@{x}:>f,1]},
Module[{de,dsol,all,states,getnumericalQ=True,nsol,int},
all=NDSolve`ProcessEquations[eqns,yy,{x,-Infinity,Infinity},dopts];
(states=Hold/@Table[Unique["state"],Length@all];
(*getnumericalQ=ListQ[x]&&Length[x]>1;*)
MapThread[
#/.Hold[s_]:>(s=#2;
If[getnumericalQ,
NDSolve`Iterate[s,a];
NDSolve`Iterate[s,b]])&,
{states,all}];
(*If[getnumericalQ,nsol=states/.Hold\[Rule]NDSolve`ProcessSolutions];*)
nsol=states/.Hold->NDSolve`ProcessSolutions;
If[NumericQ[a]&&NumericQ[b],int={{a,b}},int=Automatic];
With[{$int=int,$nsol=nsol},
de=setupDiffEq[eqns,yy,{x},$int,"numerical"->$nsol,"ndstate"->states,opts]
];
de)/;ListQ[all]
]
(*Module[{de,dsol,all,states,getnumericalQ,nsol},
nsol=NDSolve[eqns,y,xx,dopts];
(de=setupDiffEq[eqns,yy,xx,"numerical"\[Rule]nsol,opts])/;ListQ[all]
]*)];
(* translate a DSolve call (e.g. copied) to a diffEq object *)
setupDiffEq[DSolve[eqns_,y_,x_,dopts:OptionsPattern[DSolve]],opts:OptionsPattern[]]:=With[{yy=Replace[Flatten@{y},f_@@Flatten@{x}:>f,1]},
With[{dsol=checkSol[DSolve]@DSolve[eqns,yy,x,dopts]},
Module[{de},
de=setupDiffEq[eqns,yy,x,"exact"->dsol,opts];
de
]/;FreeQ[dsol,$Failed]
]];
setupDiffEq[eqns_,y_,{x_Symbol,a_,b_},deOpts:OptionsPattern[]]:=
setupDiffEq[eqns,y,x,{a,b},deOpts];
setupDiffEq[eqns_,y_,x:_Symbol|{__Symbol},deOpts:OptionsPattern[]]:= 
setupDiffEq[eqns,y,x,Automatic,deOpts];
setupDiffEq[eqns_,y_,x_,interval:_List|Automatic,deOpts:OptionsPattern[]]:=
Module[{nonind,nondep,nondiff,diff},
{nonind,nondep,nondiff,diff}=
Internal`ProcessEquations`SeparateEquations[eqns,Flatten@{x},Flatten@{y}];
(* TBD check {nonind,nondep,nondiff,diff} *)
setupDiffEq[
"de"->diff,
"bcs"->(nondep/.Automatic->{}),
"independentVars"->Flatten@{x},
"dependentVars"->Flatten@{y},
"domain"->Switch[interval
,{({_?NumericQ,_?NumericQ}|Automatic)..},interval
,{_?NumericQ,_?NumericQ}, {interval}
,Automatic,interval
,_List,Message[diffEq::IDom,interval];Automatic
,_,Message[diffEq::Imposs,interval];Automatic
],
deOpts]
];
(* main functions *)
setupDiffEq[opts:OptionsPattern[]]:=Module[{asc,alldvars,firstordersys,foRules},
(* TBD: validate option values ??? *)
With[{keys=Cases[$diffEqClass["Keys"],Alternatives@@Join[$diffEqClass["SetupKeys"],Keys[<|opts|>]]]},
asc=<|Thread[keys->OptionValue@keys]|>
(*de=AssociationMap[OptionValue,keys]*)
];
If[asc@"independentVars"===Automatic
,asc@"independentVars"=DeleteDuplicates@Cases[Flatten@{asc@"de"},_[x__Symbol]|Derivative[__][_][x__Symbol]:>x,Infinity]
];
asc@"type"=Switch[Length@asc@"independentVars"
,0,"Algebraic"  (* unsupported *)
,1,"ODE"
,n_Integer/;n>1,"PDE"  (* unsupported *)
,_,$Failed];
If[asc@"dependentVars"===Automatic
,asc@"dependentVars"=Internal`ProcessEquations`FindDependentVariables[Flatten@{asc@"de"},asc@"independentVars"]
];
firstordersys=Internal`ProcessEquations`FirstOrderize[#1,#2,1,#3]&@@
Lookup[asc,{"de","independentVars","dependentVars"}];
alldvars=firstordersys[[3]]/.firstordersys[[4]];
If[VectorQ[alldvars],alldvars=List/@alldvars];
asc@"completeDependentVars"=alldvars;
foRules=MapAt[
varsToIndexedVars[Lookup[asc,"dependentVars"]],
Flatten@{firstordersys[[4]],#->#&/@Lookup[asc,"dependentVars"]},
{All,2}];
(* add replacement rules to "firstorder" *)
asc@"firstorder"=Join[firstordersys[[1]],firstordersys[[2]]]/.foRules;
asc@"order"=Internal`ProcessEquations`DifferentialOrder@@Lookup[asc,{"de","independentVars","dependentVars"}];
asc@"parameters"=getParameters[diffEq[asc]](*Complement[DeleteDuplicates@Cases[Lookup[asc,{"de","bcs"}],s_Symbol/;!StringMatchQ[Context[s],"System`"|"Internal`"|"Developer`"],Infinity,Heads\[Rule]True],Flatten@Lookup[asc,{"independentVars","dependentVars"}]]*);
diffEq[asc]
];
(*
 * Change an existing diffEq[]
*   Need to check things: reset BVPs should nix the numerical solutions
 *)
setupDiffEq[de:diffEq[asc_],opts:OptionsPattern[]]:=
With[{keys=Cases[$diffEqClass["Keys"],Alternatives@@Join[$diffEqClass["SetupKeys"],Keys[<|opts|>]]]},
AssociateTo[de,Thread[keys->OptionValue@keys]]
];


(* ::Input::Initialization:: *)
End[];(* "`diffEqDump`" *)


(* ::Input::Initialization:: *)
SetAttributes[odeVFComponents, Listable];

SetAttributes[midpointRulePlot,HoldAll];
SetAttributes[trapezoidRulePlot,HoldAll];
SetAttributes[simpsonsRulePlot,HoldAll];

vectorPlot1D::usage="vectorPlot1D[v, {x, a, b}] plots phase vector field of the differential equation x' = v(x)";
portrait1D::usage="portrait1D[ode, {x, x1, x2}, {t, t1, t2}] plots phase portrait/solutions for an autonomous first-order ode in terms of x'[t], x[t)]";
polarPortrait1D::usage="polarPortrait1D[ode, {r, r1, r2}, {t, t1, t2}] plots integral curves of direction field for an autonomous first-order ode in polar coordinates";

midpointRulePlot::usage="midpointRulePlot[f, n, {t, a, b}] draws the figure for the midpoint rule for \!\(\*SubsuperscriptBox[\(\[Integral]\), \(a\), \(b\)]\)f(t) dt with n steps";
trapezoidRulePlot::usage="trapezoidRulePlot[f, n, {t, a, b}] draws the figure for the trapezoid rule for \!\(\*SubsuperscriptBox[\(\[Integral]\), \(a\), \(b\)]\)f(t) dt with n steps";
simpsonsRulePlot::usage="simpsonsRulePlot[f, n, {t, a, b}] draws the figure for the midpoint rule for \!\(\*SubsuperscriptBox[\(\[Integral]\), \(a\), \(b\)]\)f(t) dt with n steps";

startEvent::usage="startEvent[event, NDSolve[ode...] integrates the ode until event, then restarts and returns the rest of the integration";

secantList::usage="secantList[f, a, b, n] returns a list of n approximations {{a1, b1}, {a2, b2}, ...} to the root of f";
newtonList::usage="newtonList[f, a, n] returns a list of n approximations {a1, a2, ...} to the root of f";

showExample::usage="showExample[title_,heading_,instructions_,code_,extra_]";

lamereyStairs::usage="lamereyStairs[f_,a0_,n_]"


polarToCartestian::usage="conversion Rule";


(*$diffEqClass=<||>;*)


(* ::Input::Initialization:: *)
(*Begin["`Private`"];*)   (* begin the private context (implementation part) *)
Begin["`diffEqDump`"];


(* ::Input::Initialization:: *)
polarToCartestian={r->Sqrt[x^2+y^2],\[Theta]->ArcTan[x,y]};


(* ::Input::Initialization:: *)
(*
 * Phase portrait 
 *)

odeVFComponents[de:(Derivative[n_][f_][var_]->nthDerivative_)]:=Table[Derivative[i][f][var],{i,n}]/.de;

derivativesToVariables[expr_,fns_,___]:=expr/.{Derivative[n0_][f0:Alternatives@@Flatten[{fns}]][_]:>f0[n0],(f1:Alternatives@@Flatten[{fns}])[_]:>f1[0]}

doOdeToVF[sols_List]:=Flatten@odeVFComponents[sols]

odeToVF[eqn_,fns_,var_]:=Module[{solution},
doOdeToVF[solution]/;(
(Head[eqn]===Equal||VectorQ[eqn,MatchQ[#,_Equal]&]||(Message[Solve::naqs,eqn];False))&&
Check[
solution=Solve[eqn,Last/@Sort/@GatherBy[Cases[eqn,Derivative[_][Alternatives@@Flatten[{fns}]][var],Infinity],#/.Derivative[_]->Identity&]
];True,False,{Solve::ivar}]
)
];


(* ::Input::Initialization:: *)
Options[vectorPlot1D] = Join[{
	VectorPoints->Automatic,
	PlotStyle->Automatic,
	"VectorColors"->{ColorData[1][1],ColorData[1][2]}},
	Options[Graphics]];
zeros[vf_,{var_,a_,b_}] := var/. Solve[vf==0&&a<=var<=b,var,Reals]/. var->{};
(* new diffEqClass` interfaces *)
vectorPlot1D[{{vf_}},{var_,a_,b_},Optional[orientation:"Horizontal"|"Vertical","Vertical"],opts:OptionsPattern[]]/;True:=
vectorPlot1D[vf,{var,a,b},orientation,opts];
vectorPlot1D[vfs:{Repeated[{_},{2,Infinity}]},Optional[orientation:"Horizontal"|"Vertical","Vertical"],{var_,a_,b_},opts:OptionsPattern[]]:=
vectorPlot1D[#,{var,a,b},orientation,opts]&/@Flatten@vfs;
(*vectorPlot1D[bad_,{var_,a_,b_},opts:OptionsPattern[]]:=(
Message[diffEq::CantHappen,"Plotting",Row[{"the 1D vector field is ",bad}']];
Throw[$Failed]);*)
(* old math212` function *)
vectorPlot1D[vf_,{var_,a_,b_},Optional[orientation:"Horizontal"|"Vertical","Vertical"],opts:OptionsPattern[]]/;portrait`initQ[] :=
Module[{stationaryPts,intervals,style,colorFn,coord}
,If[orientation==="Horizontal"
,coord[y_][x_]:={x,y}
,coord[x_][y_]:={x,y}]
;style=OptionValue[PlotStyle]/. 
Automatic->Directive[Thickness[Medium],ColorData[1][1]]
;colorFn[{y1_,y2_}] :=
If[(vf/. var->Mean[{y1,y2}])>0
, Sequence@@OptionValue["VectorColors"]]
;Graphics[
	    { Thickness[Medium],ColorData[1][1],style
	    ,{colorFn[#1],Line[Thread[(*{0,#1}*)coord[0][#]]]}&/@ portrait`intervals
	    ,{colorFn[#1],Arrowheads[Medium]
, Arrow[If[(vf/. var->Mean[#1])>0
	              , Identity
	              , Reverse
	              ][Thread[(*{ 0.1 (b-a)
	                       , With[{scale=0.9}, {{scale,1-scale},{1-scale,scale}}.#1]
	                       }*)coord[0.08 (b-a)][With[{scale=0.9}, {{scale,1-scale},{1-scale,scale}}.#1]]]
	               ]
	        ]
	      }&/@SortBy[N[portrait`intervals], Differences]
	    ,EdgeForm[style]
	    ,{Black,Text[Round[N[#1],0.01],(*{-0.1,#1}*)coord[-0.1][#],(*{1,0}*)coord[1][0]]
	      ,White,Disk[(*{0,#1}*)coord[0][#], Offset[{2,2}]]
	      }& /@ portrait`stationaryPts
	    }
	  , FilterRules[{opts}, Options[Graphics]]
	  ]
	];
vectorPlot1D[vf_,{var_,a_,b_},Optional[orientation:"Horizontal"|"Vertical","Vertical"],opts:OptionsPattern[]]/;!portrait`initQ[]:=
	Block[{portrait`stationaryPts,portrait`intervals}
	, portrait`init[vf,{var,a,b}]
	; ((portrait`initQ[]=False;#1)&)[vectorPlot1D[vf,{var,a,b},orientation,opts]]
	];
portrait`initQ[]=False;
portrait`init[vf_,{var_,a_,b_}]:=
	( portrait`stationaryPts=zeros[vf,{var,a,b}]
	; portrait`intervals=Partition[Union[N[Join[{a,b},portrait`stationaryPts]]],2,1]
	; portrait`initQ[]=True
	);
portrait1D[{vf_},args___]:=portrait1D[vf,args]; (* strip braces ??? *)
portrait1D[vf_,{fn_,x1_,x2_},{time_,t1_,t2_},opts__?OptionQ]:=
	Block[{portrait`stationaryPts,portrait`intervals,plotrange={All,{x1,x2}},padding={0.1,(x2-x1) {0.03,0.02}}}
	, portrait`init[vf,{fn,x1,x2}]
	; ((portrait`initQ[]=False;#1)&)[Column[
	    { Row[
	        {(*1*)
ParametricPlot[{vf,fn},{fn,x1,x2}
	          ,Mesh->{{0}},MeshFunctions->{#1&}, Ticks->None, ImageSize->{Automatic,150}, PlotRange->plotrange
	          , PlotRangePadding->padding ,AspectRatio->2,AxesLabel->{HoldForm[Global`v],fn/.x_[0]:>x},
Epilog->{White,EdgeForm[Black],Disk[{0,#}, Offset[{2,2}]]&/@portrait`stationaryPts}
	          ]
	        ,(*2*)
Show[
	            vectorPlot1D[vf,{fn,x1,x2},ImageSize->{Automatic,150}]
	          ,Graphics[{White,Point[{-0.7,x1}]}]
	          ,PlotRange->plotrange,PlotRangePadding->padding,Axes->{False,True},AxesLabel->{None,fn/.x_[0]:>x},Ticks->None
	          ]
	        ,(*3*)
Module[{eqns,x0}
	          ,eqns={Derivative[1][fn][time]==(vf/. fn->fn[time]),fn[0]==x0}
	          ;With[{psol=ParametricNDSolveValue[eqns
	                  ,fn,{time,t1,t2}, {x0}
	                  ,"ExtrapolationHandler"->{Indeterminate&,"WarningMessage"->False}
	                  ]}
	            , Plot[Evaluate[Quiet[
	                    (psol[#1][time]&) /@
	                      Join[portrait`stationaryPts
	                      , If[(vf/. fn->Mean[#1])>0,{0.9,0.1}.#1,{0.1,0.9}.#1]&/@portrait`intervals
	                      ]]]
	              , {time,t1,t2}
	              , PlotRange->plotrange, PlotRangePadding->padding ,ImageSize->{Automatic,150}
	              , Ticks->None,ExclusionsStyle->None,AxesLabel->{time,fn/.x_[0]:>x}
	              ]
	            ]
	          ]
	        }
	      , Spacer[1]
	      ]
	    }]]
	];
portrait1D[ode_Equal,{fn_[time_],x1_,x2_},{time_,t1_,t2_}]:=portrait1D[ode,{fn,x1,x2},{time,t1,t2}];
portrait1D[ode_Equal,{fn_,x1_,x2_},{time_,t1_,t2_}]:=
	Block[{portrait`stationaryPts,portrait`intervals,plotrange={All,{x1,x2}},padding={0.1,(x2-x1) {0.03,0.02}},vf}
		, vf=First[derivativesToVariables[odeToVF[ode,{fn},time],{fn}]]/. fn[0]->fn
		; portrait`init[vf,{fn,x1,x2}]
		; ((portrait`initQ[]=False;#1)&)[Grid[
			{{TraditionalForm[ode], SpanFromLeft, SpanFromLeft}
			, {ParametricPlot[{vf,fn},{fn,x1,x2},Ticks->None,ImageSize->{Automatic,150},AxesOrigin->{0,0},PlotRange->plotrange,PlotRangePadding->padding,AspectRatio->2]
			  , Show[vectorPlot1D[vf,{fn,x1,x2},ImageSize->{Automatic,150}],Graphics[{White,Point[{-0.5,x1}]}],PlotRange->plotrange,PlotRangePadding->padding]
			  , Module[{eqns,x0}
				, murf=eqns={ode,fn[0]==x0}
				; With[{psol=ParametricNDSolveValue[eqns,fn,{time,t1,t2},{x0}
					, "ExtrapolationHandler"->{Indeterminate&,"WarningMessage"->False}]}
				  , (*glurg=psol
				  ;*) Plot[Evaluate[Quiet[(psol[#1][time]&)/@Join[portrait`stationaryPts,(If[(vf/. fn->Mean[#1])>0,{0.9,0.1}.#1,{0.1,0.9}.#1]&)/@portrait`intervals]]],{time,t1,t2},PlotRange->plotrange,PlotRangePadding->padding,ImageSize->{Automatic,150},Ticks->None,ExclusionsStyle->None]
				  ]
				]}
			(*, (Style[#1,"Label"]&)/@{"x vs. v","vector field","x vs. t"}},Alignment\[Rule]Center]]*)
			, (Style[#1,"Label"]&)/@{
			  Row[{SymbolName@fn," vs. v"}]
			  , "vector field"
			  , Row[{SymbolName@fn, " vs. ", SymbolName@time}]}}
			, Alignment->Center]]
		];


(* ::Input::Initialization:: *)
(*
 * Polar direction field portrait
* alternative APIs TBD ???
 *)
polarPortrait1D[ode_Equal,{fn_,r1_,r2_},{time_,t1_,t2_},opts:OptionsPattern@PolarPlot]:=Block[{portrait`stationaryPts,portrait`intervals,plotrange=r2,padding={0.1,(r2-r1) {0.03,0.02}},vf}
,vf=First[derivativesToVariables[odeToVF[ode,{fn},time],{fn}]]/.fn[0]->fn
;portrait`init[vf,{fn,r1,r2}]
;((portrait`initQ[]=False;#1)&)[
Module[{eqns,x0}
,eqns={
ode,
fn[t1]==x0, (* IC *)
Table[
With[{r0=r0},WhenEvent[Abs[fn[time]-r0]<1*^-3,"StopIntegration"]],
{r0,portrait`stationaryPts}]}
;With[
{psol=ParametricNDSolveValue[eqns,fn,{time,t1,t2},{x0},
"ExtrapolationHandler"->{Indeterminate&,"WarningMessage"->False}]}
,PolarPlot[
Evaluate@Flatten[List[
ConditionalExpression[#,t1<=time<=t1+2Pi]&/@DeleteDuplicates@portrait`stationaryPts,
Quiet[(psol[#1]@(time)&)/@(If[(vf/.fn->Mean[#1])>0,{0.9,0.1}.#1,{0.1,0.9}.#1]&)/@portrait`intervals]]],
{time,t1,t2},
opts,
PlotRange->plotrange,PlotRangePadding->padding,Ticks->None,ExclusionsStyle->None,PlotLabel->ode]/.l_Line:>{Arrowheads[PadRight[{0.},1+Ceiling[2/r2*ArcLength@l],0.04]],Arrow@@l}
]
]
]
];


(* ::Input::Initialization:: *)
(*
 * Interactive example button action
 *   Creates notebook window with code
 *)
showExample[title_,heading_,instructions_List,code_,extra_List]:=
CreateDocument[
Flatten[{
TextCell[heading,"Heading"],
TextCell[#,"Text"]&/@instructions,
ExpressionCell[code,"Output"],
TextCell[#,"Text"]&/@extra
}],
WindowTitle->title,
WindowSize->All,
Background->LightBlue,
Saveable->False,
ScreenStyleEnvironment->"InteractiveExample",
StyleDefinitions->StyleDefinitions->FrontEnd`FileName[{"diffEqClass"},"Diff Eq Style.nb",CharacterEncoding->"UTF-8"]];
showExample[title_,heading_,instructions_,code_,extra_]:=
showExample[title,heading,Flatten@{instructions},code,Flatten@{extra}];


(*
 * Integration - routines
 *)
Options[trapezoidRule]:={WorkingPrecision->Automatic};
trapezoidRule[f_Function,n_Integer,{t_,a_,b_},OptionsPattern[]]:=
Module[{fvals,ff,aa,bb},
{ff,aa,bb}=If[NumericQ[OptionValue[WorkingPrecision]]||NumericQ[OptionValue[WorkingPrecision]]===MachinePrecision,SetPrecision[{f,a,b},OptionValue[WorkingPrecision]],{f,a,b}];
fvals=ff[Rescale[Range[n+1],{1,n+1},{aa,bb}]];
(bb-aa)(Total[2fvals[[2;;-2]]]+First[fvals]+Last[fvals])/(2n)
];
Options[simpsonsRule]:={WorkingPrecision->Automatic};
simpsonsRule[f_Function,n_Integer,{t_,a_,b_},OptionsPattern[]]:=
Module[{fvals,ff,aa,bb},
{ff,aa,bb}=If[NumericQ[OptionValue[WorkingPrecision]]||NumericQ[OptionValue[WorkingPrecision]]===MachinePrecision,SetPrecision[{f,a,b},OptionValue[WorkingPrecision]],{f,a,b}];
fvals=ff[Rescale[Range[2n+1],{1,2n+1},{aa,bb}]];
(bb-aa)(Total[2fvals[[3;;-3;;2]]]+Total[4fvals[[2;;-2;;2]]]+First[fvals]+Last[fvals])/(6n)
];
(*
 * Integration - illustrations
 *)
midpointRulePlot[f_,n_,{t_,a_,b_},opts:OptionsPattern[Plot]]:=
Block@@Hold[{t,f2},
f2=Piecewise@Table[{f/.t->a+(i-1/2)(b-a)/n,a+(i-1)(b-a)/n<=t<a+i (b-a)/n},{i,n}];
Plot[{f,f2},{t,a,b},opts]
]

trapezoidRulePlot[f_,n_,{t_,a_,b_},opts:OptionsPattern[Plot]]:=
Block@@Hold[{t,f2},
f2=Piecewise@Table[{{(n(t-a))/(b-a)- (i-1),i-(n (t-a))/(b-a)}.(f/.{{t->a+(i-0)(b-a)/n},{t->a+(i-1)(b-a)/n}}),a+(i-1)(b-a)/n<=t<a+i (b-a)/n},{i,n}];
Plot[{f,f2},{t,a,b},opts]
]

simpsonsRulePlot[f_,n_,{t_,a_,b_},opts:OptionsPattern[Plot]]:=
Block@@Hold[{t,f2},
f2=Piecewise@Table[{
Interpolation[{t,f}/.{
{t->a+(i-0)(b-a)/n},
{t->a+(i-1/2)(b-a)/n},
{t->a+(i-1)(b-a)/n}},
InterpolationOrder->2][t],a+(i-1)(b-a)/n<=t<a+i (b-a)/n},{i,n}];
Plot[{f,f2},{t,a,b},opts]
]

(*
 * startEvent
 *   Integrates a DE until a condition is reached
 *   then restarts and returns the rest of the integration
 *)
SetAttributes[startEvent,HoldAll];
startEvent[evt_,ndsolve_[de_,vars_,{t_,a_,b_},rest__]] :=
 Catch[ndsolve[
  de,
  vars,
  {t, Catch[
       With[{sol = ndsolve[{de,WhenEvent[evt,Throw[t,"start"]]},
                    vars,
                   {t, a, b}]},
        Throw[sol, "sol"]], "start"], b},
  rest],"sol"];


(* ::Input::Initialization:: *)
(*
 * Root-finding: example procedures
 *)
Options[secantList]={WorkingPrecision->Automatic};secantList[f_,a_?NumericQ,b_?NumericQ,n_Integer,OptionsPattern[]]:=With[{ff=If[NumericQ[OptionValue[WorkingPrecision]]&&(Precision[f]===MachinePrecision||Precision[f]<OptionValue[WorkingPrecision]),SetPrecision[f,OptionValue[WorkingPrecision]],f]},NestList[{x1,x1-ff[x1](x1-x0)/(ff[x1]-ff[x0])}/.Thread[{x0,x1}->#]&,
If[NumericQ[OptionValue[WorkingPrecision]]||OptionValue[WorkingPrecision]===MachinePrecision,SetPrecision[{a,b},OptionValue[WorkingPrecision]],{a,b}],n]
];
Options[newtonList]={WorkingPrecision->Automatic};newtonList[f_,a_?NumericQ,n_Integer,OptionsPattern[]]:=With[{ff=If[NumericQ[OptionValue[WorkingPrecision]]&&(Precision[f]===MachinePrecision||Precision[f]<OptionValue[WorkingPrecision]),SetPrecision[f,OptionValue[WorkingPrecision]],f]},NestList[#-ff[#]/ff'[#]&,
If[NumericQ[OptionValue[WorkingPrecision]]||OptionValue[WorkingPrecision]===MachinePrecision,SetPrecision[a,OptionValue[WorkingPrecision]],a],n]
];



(* ::Input::Initialization:: *)
(* TBD: lamereyStairs is ok as a utility, but needs a better user interface. ??? *)
lamereyStairs[f_,a0_,n_]:=Module[{h=Arrow},
(h=h/.{Arrow->Line,Line->Arrow})[#]&/@
Partition[
Transpose[{Most[#],Rest[#]}]&@Riffle[#,#]&@NestList[f,a0,n],
2,1]
];


End[];


(* ::Input::Initialization:: *)
Begin["`diffEqDump`"];


(* getCommand[]

input syntax for solving:
	de[type, opts...]
	de[type, problem, opts...]
type = "numerical"|"exact"|"solution"|"series"
problem = "general"|"particular"
??? add dvars = variables to return functions for, including derivatives ???

return type for solving:
	{de_diffEq, type_String, prob_String, {opts}}
*)


(* ::Input::Initialization:: *)
(* "numerical"|"exact"|"series"
 *)
(*argsToOpts[args___]:=Module[{},(*seems only arg is domain*)
Table[
Switch[a,
{_,_,_},"domain"\[Rule]a,
_,Message[diffEq::BadArg,getCommand,a]
],
{a,{args}}]
];*)
getCommand[{de:diffEq[asc_],sol:"series",prob_String:Automatic,iter:{_,_,_Integer}},opts_]:=
If[MatchQ[prob,"general"|"particular"],
{de,sol, prob,Join[{"asymptoticIterator"->iter},opts]},
If[prob===Automatic,
getCommand[{de,sol},Join[{"asymptoticIterator"->iter},opts]],
getCommand[{de,sol,prob},Join[{"asymptoticIterator"->iter},opts]]
]];
getCommand[{de:diffEq[asc_],sol:"numerical"|"exact"|"general"|"particular",args___,dom:{_,_,_Integer}},opts_]:=
getCommand[{de,sol,args},Join[{"domain"->dom},opts]];
getCommand[{de:diffEq[asc_],
sol:"numerical"|"exact"|"series",
prob:"general"|"particular"},
opts_]:=(
If[sol==="numerical"&&prob=="general",
TBD["obtaining numerical general solutions"] (** TBD ??? **)
];
{de,sol, prob,opts});
getCommand[{de:diffEq[asc_],prob:"general"|"particular"},opts_]:=
{de,
prob/.{"general"->"exact","particular"->"numerical"},
prob,opts};
(* map "solution" to "numerical" or "exact"
*   "general" implies "exact"
*   "particular" implies "numerical" unless already in "exact" form
 *)
getCommand[{de:diffEq[asc_],sol:"solution",prob:"general"|"particular"},opts_]:=Module[{sol2,(*numQ,*)exQ},
(*numQ=!MissingQ@Lookup[asc,"numerical"];*)
Switch[prob,
"general",sol2="exact",
"particular"
,If[particularQ[de]&&(* problem is IVP/BVP or general? *)
KeyExistsQ[asc,"exact"]&&(* exact solution exists *)
!KeyExistsQ[opts,"bcs"] (* opts don't define new problem *)
,sol2="exact"
,sol2="numerical"],
_,Message[diffEq::CantHappen,diffEq,Row[{"problem type ",prob," is not \"general\" or \"particular\"."}]];Return[$Failed,getCommand]
];
{de,sol2,prob,opts} 
];
(*getCommand[de:diffEq[asc_],sol:"solution",prob:"general",opts___?OptionQ]:=Module[{},
getCommand[de,"exact","general",opts] (* numeric if what ??? *)
];*)
(*getCommand[de:diffEq[asc_],sol0:"solution",prob:"particular",opts___?OptionQ]:=Module[{sol,bcs,params},
sol=Lookup[asc,"exact"]; (* ??? *)
db[sol];
If[MissingQ[sol],
sol=de["numerical",opts], (* check sol ??? *)
bcs=getKey[de,"bcs",{opts}];
params=Union@Cases[sol,_C,Infinity];
If[Length@params>0,
db[params];
params=Solve[bcs/.#,params]&/@sol;
db[params];
(* warn if Solve -> {} or {{}} ??? *)
params=Join@@params;
sol=sol/.params;
db[sol]
]];
sol
];*)


(* Automatic problem selection *)
getCommand[{de:diffEq[asc_],sol:"exact"|"numerical"|"solution"|"series"},opts_]:=Module[{prob},
If[particularQ[de,opts],prob="particular",prob="general"];
If[sol==="solution",
getCommand[{de,sol,prob},opts],
{de,sol,prob,opts}]
];



(* getCommand[]

input syntax for plotting:
	de[type, opts...]
	de[type, dvars, opts...]
	de[type, dvars, ivars, opts...]
type = "plot"|"parametric"|"polar"|"implicit"|"portrait"|"flow"|"vector field" 

return type for plotting:
	{de_diffEq, type_String, prob_String, {opts}}
*)


(* ::Input::Initialization:: *)
getCommand[{de:diffEq[asc_],type:"plot"|"parametric"|"polar"},
 (* no variable arguments *)
opts_]:={de,type,Automatic,Automatic,opts};
getCommand[{de:diffEq[asc_],
type:"plot"|"parametric"|"polar",
All,param_List}, (**)
opts_]:=Module[{dvars},
dvars=Flatten@Lookup[asc,"completeDependentVars"];  (* check dvars ??? *)
{de,type,dvars,getDomain[de,type,param,opts],opts}
];
getCommand[{de:diffEq[asc_],type:"plot"|"parametric"|"polar",
out_Symbol,param_List},
opts_]:=
{de,type,{out},getDomain[de,type,param,opts],opts};
getCommand[{de:diffEq[asc_],type:"plot"|"parametric"|"polar",
out_List,param_List}, (**)
opts_]:=
{de,type,out,getDomain[de,type,param,opts],opts};
getCommand[{de:diffEq[asc_],type:"plot"|"parametric"|"polar",param_List},opts_]:=Module[{dvars},
dvars=Lookup[asc,"dependentVars"];  (* check dvars ??? *)
{de,type,dvars,getDomain[de,type,param,opts],opts}
];



(* ::Input::Initialization:: *)
(*
 * "implicit"
 *)
getCommand[{de:diffEq[asc_],type:"implicit"},opts_]/;implicitSolutionQ[de]:=Module[{res},
{de,type,Automatic,Automatic,opts}
];
getCommand[{de:diffEq[asc_],type:"implicit",domain_List},opts_]/;implicitSolutionQ[de]:=Module[{res},
{de,type,Automatic,domain,opts} (* ??? *)
];
getCommand[{de:diffEq[asc_],type:"implicit",eqn_Equal,domain_List},opts_]/;implicitSolutionQ[de]:=Module[{res},
{de,type,eqn,domain,opts}
];



(* ::Input::Initialization:: *)
(*
 * Vector field / flow
 *)
getCommand[{de:diffEq[asc_],type:"flow"|"vector field"},opts_]:=Module[{res},
{de,type,Automatic,Automatic,opts}
];
getCommand[{de:diffEq[asc_],type:"flow"|"vector field",dom_List},opts_]:=Module[{res},
{de,type,Automatic,dom,opts} (* ??? *)
];



(* ::Input::Initialization:: *)
(*
 * "portrait" phase and direction portraits
* "contact" contact portrait
 *)
getCommand[{de:diffEq[asc_],type:"portrait"|"contact"},opts_]:=Module[{res},
{de,type,Automatic,Automatic,opts}
(*res=checkSol@runCode[res,"returnCode"/.Flatten@{opts}//TrueQ];
res/;FreeQ[res,$Failed]*)
];
getCommand[{de:diffEq[asc_],type:"portrait"|"contact",dom_List},opts_]:=Module[{code},
{de,type,Automatic,dom,opts}(* ??? *)
(*checkSol@runCode[code,"returnCode"/.Flatten@{opts}//TrueQ]*)
];

(* First order contact portrait
* sampling points for contact planes
 *)
getContactFieldPoints[ode_,{x_,x1_,x2_},{y_,y1_,y2_},{p_,p1_,p2_}]:=
Module[
{cp,pts,bdynf,cpts,iter,mindist},
(* generate oversampling *)
cp=ContourPlot3D[x p-y==y^2,{x,x1,x2},{y,y1,y2},{p,p1,p2},
MaxRecursion->1,Mesh->None,AxesLabel->Automatic];
(* extract points *)
pts=Flatten[Cases[cp,GraphicsComplex[pp_,__]:>pp,Infinity],1];
(* delete neighboring points *)
bdynf=Nearest@Flatten[(* distance is a problem if axes scales differ greatly *)
Cases[cp,Line[l_]:>pts[[l]],Infinity],
1];
mindist=Min[x2-x1,y2-y1,p2-p1]/10; (* distance is a problem *)
cpts=DeleteCases[pts,pt_/;Length@bdynf[pt,{Infinity,0.55mindist}]>0];
iter=1;
While[Length@cpts>iter,
cpts=DeleteCases[cpts,Alternatives@@Rest@Nearest[cpts,cpts[[iter]],{Infinity,mindist}]];
iter++
];
cpts
];



(* ::Input::Initialization:: *)
iDiffEq[de:diffEq[asc_],sol:"numerical"|"exact"|"series",prob:"particular"|"general",opts_]:=Module[{res,solverCode,solver},
solverCode=getHeldSolverCode[de,sol,prob,opts];
solver=Replace[solverCode,Hold[s[___]]:>s];
res=checkSol[solver]@runCode[solverCode,"returnCode"/.Flatten@opts//TrueQ];
If[res=!=$Failed,
asc@sol=res,(* save (new) solutions ??? *)
solverCode (* return code that failed? *)
]/;FreeQ[solverCode,$Failed]
];



(* ::Input::Initialization:: *)
(*(* TBD: select right evaluator, right precision *)
(de:diffEq[asc_])[t_?NumericQ]:=With[{sol=Flatten@Values@de@"exact"},
Through[sol[t]]/.{y_}\[RuleDelayed]y];*)


(* ::Input::Initialization:: *)
(*
 * "plot"
*   "implicit" may need post processing or pretesting of solver
 *)
iDiffEq[de:diffEq[asc_],
type:"plot"|"parametric"|"polar"|"implicit"|"flow"|"vector field"|"portrait"|"contact",
 x_,t_,opts_]:=Module[{code,dvars,ivars,res,solver},
code=getHeldPlotCode[de,type,x,t,opts(*Flatten@{opts}*)];
solver=Replace[code,Hold[s[___]]:>s];
res=checkSol[solver]@runCode[code,"returnCode"/.opts//TrueQ];
res/;FreeQ[res,$Failed]
];


(* ::Input::Initialization:: *)
$commandSynonyms=<|
"numerical"->"numerical",
"numeric"->"numerical",
"exact"->"exact",
"symbolic"->"exact",
"analytic"->"exact",
"solution"->"solution",
"series"->"series",
"asymptotic"->"series",
"powerseries"->"series",
"general"->"general",
"particular"->"particular",
"ivp"->"particular",
"bvp"->"particular",
"phaseflow"->"flow",
"phase"->"flow",
"phaseplot"->"flow",
"flow"->"flow",
"vectorfield"->"vector field", (* make arrowless ??? *)
"directionfield"->"vector field", (* make arrowless ??? *)
"implicitplot"->"implicit",
"implicit"->"implicit",
"parametriccurve"->"parametric",
"parametricsurface"->"parametric",
"parametricplot"->"parametric",
"parametric"->"parametric",
"polarcurve"->"polar",
"polarplot"->"polar",
"polar"->"polar",
"portrait"->"portrait",
"phaseportrait"->"portrait",
"contact"->"contact",
"contactportrait"->"contact",
"contactplot"->"contact"
|>;
$inGetCommand=False;
getSynonym[cmd_]:=(* TBD: deprecate *)Lookup[$commandSynonyms,StringDelete[ToLowerCase[cmd],WhitespaceCharacter]];
getSynonym[thesaurus_,cmd_]:=Lookup[thesaurus,StringDelete[ToLowerCase[cmd],WhitespaceCharacter]];
getCommand[{de_diffEq,cmd1_String,cmd2_String,args___},opts_]/;!TrueQ[$inGetCommand]:=
With[{new1=getSynonym[$commandSynonyms,cmd1],(* TBD: check ??? *)
new2=getSynonym[$commandSynonyms,cmd2]},(* TBD: check ??? *)
Block[{$inGetCommand=True},getCommand[{de,new1,new2,args},opts]]/;!MissingQ[new1]&&!MissingQ[new2]
];
getCommand[{de_diffEq,cmd_String,args___},opts_]/;!TrueQ[$inGetCommand]:=
With[{new=getSynonym[$commandSynonyms,cmd]},(* TBD: check ??? *)
Block[{$inGetCommand=True},getCommand[{de,new,args},opts]]/;!MissingQ[new]
];


(* ::Input::Initialization:: *)
End[]; (*"`diffEqDump`"*)


(* ::Input::Initialization:: *)
Begin["`diffEqDump`"];


(* ::Input::Initialization:: *)
(* utilities`getHeldSolverCode
*  getHeldSolverCode[de, sol, prob, opts_List]
*  @ Gets solver DSolve/NDSolve/ParametricNDSolve(Value?) code for problem
*  @ Whether held or inactive: the solvers don't hold arguments, so we do not
*    even for plotting (q.v.)
*  @ (sol : "exact" | "numerical" | "series" )
*  @ (prob : "general" | "particular" )
 *)
getHeldSolverCode[de:diffEq[asc_],
sol_,prob_,
opts_]:=Module[{res,solverCode,command,ode,bcs,(*events,*)X,xord,T,tint,P,pvals,args,deOpts},
deOpts=Association@FilterRules[opts,Options@setupDiffEq];
ode=Lookup[asc,"de"];
X=Lookup[asc,"dependentVars"];
T=Lookup[asc,"independentVars"];
(*P=Lookup[asc,"parameters"];*)
(* the following check should be unnecessary if de is valid ??? *)
If[!FreeQ[{ode,X,T,P},Missing],Throw[$Failed,diffEq]];
(*events=Lookup[asc,"events",{}];*) (* ??? *)
If[prob==="particular",
bcs=needsBCs[de,opts],
bcs={}
];
(*events=getKey[de,"events",opts];*) (* TBD ??? *)
tint=getDomain[de,"solution",T,opts]; (* deOpts ??? *)
pvals=getParameterValues[de,opts];
(*pvals=pvals/.eq_Equal\[RuleDelayed]psolve[eq];*)
ode=ode/.pvals;
(* means we don't have to get parameters in setup; 
* keep for future applications ??? *)
P=getParameters[{ode,bcs},Flatten@{X,T}]; 
If[!FreeQ[pvals,$Failed],Throw[$Failed,diffEq]]; (* Throw ??? *)
Switch[sol,
"exact",
(If[prob==="general",tint=tint[[All,1]]];
res=Hold[DSolve[##]]&[
{ode,bcs},X,Sequence@@tint,FilterRules[opts,Options@DSolve]]
),
"numerical",
(If[prob==="general",
TBD["solving for a numerical general solution"]]; (* TBD ??? *)
If[bcs===Automatic||bcs==={}||MissingQ[bcs],
bcs=MapThread[#[First@#2]==Last@#2&,
{Flatten@Lookup[asc,"completeDependentVars"],
PadRight[{{0,1}},{Length@Flatten@Lookup[asc,"completeDependentVars"],2}]}];
Message[diffEq::NoBCS,bcs]
];
If[P==={},
res=Hold[NDSolve[##]]&[
{ode,bcs},X,Sequence@@tint,FilterRules[opts,Options@NDSolve]],
res=Hold[ParametricNDSolve[##]]&[
{ode,bcs},X,Sequence@@tint,P,FilterRules[opts,Options@ParametricNDSolve]]
]
),
"series",
Module[{aord,t0,iter},
iter="asymptoticIterator"/.opts;
If[StringQ[iter],
aord=getKey[de,"asymptoticOrder",opts];
t0=First@Flatten@{cullArgs[bcs,X],tint[[1,2]]};
tint={tint[[1,1]],t0,aord},
tint=iter
];
res=Hold[AsymptoticDSolveValue[##]]&[
{ode,bcs},X,tint,Sequence@@FilterRules[opts,Options@DSolve]]
],
_, (* impossible *)
(Message[diffEq::CantHappen,getHeldSolverCode,Row[{"solution type is ",sol}]];
Throw[$Failed,diffEq]
)];
res
];



(* utilities`getDefaultProblemType - when type is not specified *)
(* no longer needed ??? *)
getDefaultProblemType[de_diffEq,"numerical"]:="particular";
getDefaultProblemType[de_diffEq,"exact"]:=Lookup[de,"bcs"]/.{_Missing->"general",_->"particular"};


(* ::Input::Initialization:: *)
(*(* utilities`getHeldSolverCode
*  getHeldSolverCode[de, sol, prob, opts_List]
*  @ Gets solver DSolve/NDSolve/ParametricNDSolve(Value?) code for problem
*  @ Whether held or inactive: the solvers don't hold arguments, so we do not
*    even for plotting (q.v.)
*  @ (sol : "exact" | "numerical" | "series" )
*  @ (prob : "general" | "particular" )
 *)
getHeldSolverCode[de:diffEq[asc_],
"series",prob_,
opts_]:=TBD["finding a series solution"];
getHeldSolverCode[de:diffEq[asc_],
sol_,prob_,
opts_]:=Module[{res,solverCode,command,ode,bcs,events,x,xord,t,tint,p,args,deOpts},
deOpts=Association@FilterRules[opts,Options@setupDiffEq];
ode=Lookup[asc,"de"];
x=Lookup[asc,"dependentVars"];
t=Lookup[asc,"independentVars"];
If[!FreeQ[{ode,x,t},Missing],Return[$Failed,getHeldSolverCode]];
(*events=Lookup[asc,"events",{}];*)
If[prob==="particular",
bcs=getKey[de,"bcs",opts],
bcs={}
];
events=getKey[de,"events",opts];
tint=getDomain[de,"solution",t,opts]; (* deOpts ??? *)
p=Lookup[asc,"parameters",{}]; (* getKey ??? *)
If[sol==="exact",
res=Hold[DSolve[##]]&[
{ode,bcs},x,Sequence@@tint,FilterRules[opts,Options@DSolve]]
,( (* "numerical" *)
If[prob==="general",
TBD["solving for a numerical general solution"]]; (* TBD ??? *)
If[bcs===Automatic||bcs==={}||MissingQ[bcs],
bcs=MapThread[#[First@#2]\[Equal]Last@#2&,
{Flatten@Lookup[asc,"completeDependentVars"],
PadRight[{{0,1}},{Length@Flatten@Lookup[asc,"completeDependentVars"],2}]}];
Message[diffEq::NoBCS,bcs]
];
If[First@p==={},
res=Hold[NDSolve[##]]&[
{ode,bcs},x,Sequence@@tint,FilterRules[opts,Options@NDSolve]],
res=Hold[ParametricNDSolve[##]]&[
{ode,bcs},x,Sequence@@tint,p,FilterRules[opts,Options@ParametricNDSolve]]
])
]
];

(* utilities`getDefaultProblemType - when type is not specified *)
(* no longer needed ??? *)
getDefaultProblemType[de_diffEq,"numerical"]:="particular";
getDefaultProblemType[de_diffEq,"exact"]:=Lookup[de,"bcs"]/.{_Missing->"general",_\[Rule]"particular"};*)


(* ::Input::Initialization:: *)
(* checks call & solution to add interpretive messages *)
diffEq::ImplSol="DSolve was unable to solve for the unknown explicitly; an implicit solution has been returned.";
(*
diffEq::IFnSol="DSolve was unable to solve for the inverse of a function; a solution in terms of InverseFunction has been returned; you can apply toImplicitSolution[sol] to convert the \"solution\" sol to an implicit solution.";
diffEq::RootSol="A solution in terms of Root has been returned, which is a way Mathematica can represent solutions to certain equations; you can apply toImplicitSolution[sol] to convert it to an implicit solution.";
diffEq::IntSol="DSolve was unable to solve one or more integrals in the solution; the solution has been returned in terms of Inactive integrals.";
*)
diffEq::IFnSol="DSolve was unable to solve for the inverse of a function; a solution in terms of InverseFunction has been returned; you can apply toImplicitSolution[sol] to convert the \"solution\" sol to an implicit solution.";
diffEq::RootSol="A solution in terms of Root has been returned, which is a way Mathematica can represent solutions to certain equations; you can apply toImplicitSolution[sol] to convert it to an implicit solution.";
diffEq::IntSol="DSolve was unable to solve one or more integrals in the solution; the solution has been returned in terms of Inactive integrals.";
diffEq::Unsolved="`` was unable to solve the differential equation; returning code used.";
diffEq::NoSol="`` returned no solution.";


(*SetAttributes[checkSol,HoldAll];*)
checkSol[code:Hold[_],solver_]:=code;
checkSol[(h:DSolve|NDSolve|ParametricNDSolve|AsymptoticDSolveValue|Plot|Plot3D|ParametricPlot|ParametricPlot3D|StreamPlot|ContourPlot|ContourPlot3D|runCode)[__],
solver_]:=(
If[MatchQ[h,DSolve|NDSolve|ParametricNDSolve|AsymptoticDSolveValue],
Message[diffEq::Unsolved,h]
];
$Failed);
checkSol[res_,solver_]:=(
If[Head[res]===Solve,
Message[diffEq::ImplSol]
];
If[!FreeQ[res,Integrate],
Message[diffEq::IntSol]
];
If[!FreeQ[res,InverseFunction],
Message[diffEq::IFnSol]
];
If[!FreeQ[res,Root],
Message[diffEq::RootSol]
];
If[res==={},
Message[diffEq::NoSol,solver/.Hold->HoldForm]
];
res);
checkSol[solver_][res_]:=checkSol[res,solver];

toImplicitSolution::usage="toImplicitSolution[sol] converts a solution to an implicit solution.";
toImplicitSolution::IRoot="A Root object is being inverted; extraneous solutions may be introduced.";
toImplicitSolution[sol_]:=Module[{Global`t},(* symbol to return to user *)
sol/.{
HoldPattern[{x_->Function[t_,InverseFunction[f_][a_]]}]:>Inactive[Solve][f[x[t]]==a,x[t]],
HoldPattern[{x_->Function[{t_},Root[f_,n_]]}]/;(Message[toImplicitSolution::IRoot];True):>Inactive[Solve][f[x[t]]==0,x[t]],
HoldPattern[ff:{(_->Verbatim[Function][{t_},_])..}]:>Inactive[Solve][Thread[Through[ff[[All,1]][t]]==Through[ff[[All,2]][t]]],Through[ff[[All,1]][t]]],
HoldPattern[ff:{(_->_InterpolatingFunction)..}]:>Inactive[Solve][Thread[Through[ff[[All,1]][Global`t]]==Through[ff[[All,2]][Global`t]]],Through[ff[[All,1]][Global`t]]]}
];


(* ::Input::Initialization:: *)
diffEq::NoDE="Error: No differential equations specified.";
diffEq::NoIVP="Error: Unable to compute numerical solution of IVP.";
diffEq::NoInt="Warning: No numerical interval; using default {0,1}."; (* "NoInt": add programmable default interval? Use IC *)
diffEq::NoBCS="Warning: No initial/boundary conditions; using ``.";
diffEq::NumImposs="Error: Impossible numerical result ``.";

(*
(de:diffEq[asc_])[sol:"numerical"|"exact",prob_String:"particular",opts___?OptionQ]:=Module[{res,solverCode},
solverCode=getHeldSolverCode[de,sol,prob,{opts}];
res=checkSol@runCode[solverCode,"returnCode"/.Flatten@{opts}//TrueQ];
If[res=!=$Failed,
asc@sol=res,(* save (new) solutions ??? *)
solverCode (* return code that failed? *)
]/;FreeQ[solverCode,$Failed]
];*)


(* ::Input::Initialization:: *)
(*(de:diffEq[asc_])["solution",opts___?OptionQ]:=Module[{sol,int},
sol=Lookup[asc,"exact"]; (* what if BCS changed ??? *)
(*int="domain"/.{opts}/.asc/.Automatic\[Rule]{0,1};*)
(*interval=Lookup[asc,"domain",Automatic]/.Automatic\[RuleDelayed](Message[diffEq::"NoInt"];{0,1})*)
If[MissingQ[sol]||!FreeQ[sol,C],
sol=Lookup[asc,"numerical"];
If[!FreeQ[{opts},"domain"|"bcs"] ||MissingQ[sol],
int=Rest(* Most ??? *)/@getDomain[de,"solution",de@"independentVars",{opts}];
sol=de["numerical",{"domain"\[Rule]int,opts}]
]];
sol
];
(* request specific type *)
(de:diffEq[asc_])["solution","general",opts___?OptionQ]:=Module[{},
de["exact",opts] (* numeric if linear ??? *)
];
(de:diffEq[asc_])["solution","particular",opts___?OptionQ]:=Module[{sol,bcs,params},
sol=Lookup[asc,"exact"]; (* ??? *)
db[sol];
If[MissingQ[sol],
sol=de["numerical",opts], (* check sol ??? *)
bcs=getKey[de,"bcs",{opts}];
params=Union@Cases[sol,_C,Infinity];
If[Length@params>0,
db[params];
params=Solve[bcs/.#,params]&/@sol;
db[params];
(* warn if Solve -> {} or {{}} ??? *)
params=Join@@params;
sol=sol/.params;
db[sol]
]];
sol
];*)


(* ::Input::Initialization:: *)
(*diffEq[asc_]["solution"]:=(* TBD ??? *)
With[{res=Lookup[asc,"exact",Lookup[asc,"numerical",$Failed]]},
If[res===$Failed,
Message[diffEq::TBD,"This feature"];
Thread[asc@"dependentVars"\[Rule] Function[Message[diffEq::TBD,"This feature"]](* ??? *)],
res]];
*)


(* ::Input::Initialization:: *)
(* TBD: select right evaluator, right precision *)
(de:diffEq[asc_])[t_?NumericQ]:=With[{sol=Flatten@Values@de@"exact"},
Through[sol[t]]/.{y_}:>y];


(* ::Input::Initialization:: *)
(*
 * Classic approach to continuity
*   Slow on exact input, fast on _Real input
 *)
ClearAll[realContinuousQ];
realContinuousQ::usage="realContinuousQ[f, x -> x0] returns whether f is continuous at x = x0.";
realContinuousQ[f_,approach_Rule]:=Module[{f0,fp,fm},
f0=f/.approach//Quiet;
If[NumericQ[f0],
fp=Limit[f,approach,Direction->"FromAbove"];
If[TrueQ[f0==fp],
fm=Limit[f,approach,Direction->"FromBelow"];
TrueQ[f0==fm],
False],
False]
];


(* ::Input::Initialization:: *)
(*
 * Checks if de is linear equation or system
 *)
linearQ::usage="linearQ[diffEq[de]] returns whether de is linear.";
linearQ[de:diffEq[asc_]]:=AllTrue[
Lookup[asc,"de"],
Internal`LinearQ[
#,
Through[Flatten@{Lookup[asc,"completeDependentVars"],
MapThread[
(Derivative@@#2)@#&,
{Lookup[asc,"dependentVars"],Lookup[asc,"order"]}]}@@Lookup[asc,"independentVars"]]
]&
];


(* ::Input::Initialization:: *)
(*
 * Find coefficient functions dependent only in independent variable
*   To be used for finding singularities, limits on domain
 *)
ClearAll[coefficients];
coefficients::usage="coefficients[diffEq[de]] returns the coefficients of de.";
coefficients[de:diffEq[asc_]]/;linearQ[de]:= (* easy case *)Module[{ode,xp,dorder,dvars,alldvars,t},
ode=Lookup[asc,"de"];
dorder=Lookup[asc,"order"];
dvars=Lookup[asc,"dependentVars"];
alldvars=Lookup[asc,"completeDependentVars"];
t=First@Lookup[asc,"independentVars"]; (* TBD: PDEs *)
xp=MapThread[Derivative[#1][#2][t]&,{Flatten@dorder,Flatten@dvars}];
CoefficientList[xp/.Solve[ode,xp]//Flatten,Through[Flatten[alldvars][t]]]
];
coefficients[de:diffEq[asc_]]:= (* hard case; might fail *)
Module[{ode,xp,dorder,dvars,alldvars,t,factors},
ode=Lookup[asc,"de"];
dorder=Lookup[asc,"order"];
dvars=Lookup[asc,"dependentVars"];
(*alldvars=echo@Lookup[asc,"completeDependentVars"];*)
t=First@Lookup[asc,"independentVars"];
xp=MapThread[Derivative[#1][#2][t]&,{Flatten@dorder,Flatten@dvars}];
(*factors=FactorList/@Flatten@Replace[echo@Flatten[xp/.Solve[ode,xp]],s_Plus\[RuleDelayed]List@@s,1];*)
factors=FactorList/@Flatten[xp/.Solve[ode,xp]];
factors=DeleteCases[_?(!FreeQ[#,Alternatives@@Flatten@dvars]&)]/@factors;
Times@@@Apply[Power,factors,{2}]
];


(* ::Input::Initialization:: *)
ClearAll[singularities];
singularities::usage="singularities[diffEq[de]] returns the singularities in the coefficients of de.";singularities[de:diffEq[asc_]]:=With[{t=Lookup[asc,"independentVars"]},
With[{sing=Simplify`FunctionSingularities[coefficients[de],t,{"ALL"}]},
If[FreeQ[sing,$Failed],
Flatten[
Map[(*Flatten@*)Values@Solve[#,t,Reals]&,
sing,
{2}],
2],
{}]
]];


(* ::Input::Initialization:: *)
ClearAll[autonomousQ];
autonomousQ::usage="autonomousQ[diffEq[de]] returns whether de is autonomous.";
autonomousQ[de:diffEq[asc_]]:=Module[{ivars},
FreeQ[
stripArgs[
Lookup[asc,"de"],
Flatten@Lookup[asc,"dependentVars"]],
Alternatives@@Lookup[asc,"independentVars"]
]
];


(* ::Input::Initialization:: *)
(* equilibria[de]
*   For each solution for the highest derivative of the de we get a vector field
*   Each vector field produces a list of equilibria
 *)
equilibria::usage="equilibria[DE] returns the equilibria of the differential equation DE.";
equilibria[de:diffEq[asc_]]/; autonomousQ[de]:=Module[{res,dvars,ivars,alldvars,vfs},
res=Lookup[asc,"equilibria"];
If[ListQ[res],Return[res,Module]];
dvars=Flatten@Lookup[asc,"dependentVars"];
alldvars=Flatten@Lookup[asc,"completeDependentVars"];
vfs=varsToIndexedVars[dvars]@getVectorField[de,Derivative[1]/@alldvars];
ivars=varsToIndexedVars[alldvars,dvars];
res=Solve[#==0,ivars]&/@vfs//indexedVarsToVars[dvars]
];
equilibria[de:diffEq[asc_]]:={}


(* ::Input::Initialization:: *)
End[]; (* "`diffEqDump`" *)


(* ::Input::Initialization:: *)
(*(*diffEq/:Plot[diffEq[asc_][x_],{x_,a_,b_},opts:OptionsPattern[Plot]]:=diffEq[asc]["plot"[{a,b},opts]];*)
(de:diffEq[asc_])["quick plot"]:=With[{ndsol=Flatten@Values@de@"numerical"},ListLinePlot[ndsol]];
(*(de:diffEq[asc_])[asc_]["plot",opts:OptionsPattern[Plot]]:=With[{sol=Values@de@"solution"},Plot[Evaluate@Through[sol[t]],{t,a,b},opts]];*)
(*
 * "plot"
 *)
(de:diffEq[asc_])[type:"plot"|"parametric"|"polar",
 (* no variable arguments *)
opts___?OptionQ]:=Module[{code,dvars,ivars,res},
(*dvars=Lookup[asc,"dependentVars"];
ivars=Lookup[asc,"independentVars"];*) (* check appropriateness ??? *)
code=getHeldPlotCode[de,(*"solution"*)type,Automatic,Automatic,{opts}];
res=checkSol@runCode[code,"returnCode"/.Flatten@{opts}//TrueQ];
res/;FreeQ[res,$Failed]
(*If["returnCode"/.{opts}//TrueQ,
code,
ReleaseHold@code
]/;FreeQ[code,getHeldPlotCode|$Failed]*)
];
(de:diffEq[asc_])[
type:"plot"|"parametric"|"polar",
All,param_List, (**)
opts___?OptionQ]:=Module[{dvars},
dvars=Flatten@Lookup[asc,"completeDependentVars"];  (* check dvars ??? *)
de[type,dvars,param,opts]
];
(de:diffEq[asc_])[type:"plot"|"parametric"|"polar",
out_Symbol,param_List,
opts___?OptionQ]:=de[type,{out},param,opts];
(de:diffEq[asc_])[type:"plot"|"parametric"|"polar",
out_List,param_List, (**)
opts___?OptionQ]:=
Module[{code,tint,res},
(* Check validity of out_List ??? *)
tint=getDomain[de,type,param,{opts}];
(*If[MatchQ[param,{_,_,_}], (* use getDomain ??? *)
tint={param},
tint=param];*)
code=getHeldPlotCode[de,type,out,tint,{opts}];
res=checkSol@runCode[code,"returnCode"/.Flatten@{opts}//TrueQ];
res/;FreeQ[res,$Failed]
(*If["returnCode"/.{opts}//TrueQ,
code,
ReleaseHold@code
]/;FreeQ[code,getHeldPlotCode|$Failed]*)
];
(de:diffEq[asc_])[type:"plot"|"parametric"|"polar",param_List,opts___?OptionQ]:=Module[{dvars},
dvars=Lookup[asc,"dependentVars"];  (* check dvars ??? *)
de[type,dvars,param,opts]
];

(*
 * "parametric"
 *)
(de:diffEq[asc_])["parametric curve"|"parametric surface"|"parametric plot",args___]:=de["parametric",args];
(*
 * the rest is factored into de["plot",...] code
 *)



(*
 * "polar"
 *)
(de:diffEq[asc_])["polar curve"|"polar plot",args___]:=de["polar",args];
(*
 * the rest is factored into de["plot",...] code
 *)


(*
 * "implicit"
 *)
(de:diffEq[asc_])[type:"implicit",opts___?OptionQ]/;implicitSolutionQ[de]:=Module[{res},
res=Catch@getHeldPlotCode[de,type,Automatic,Automatic,{opts}];
res=checkSol@runCode[res,"returnCode"/.Flatten@{opts}//TrueQ];
res/;FreeQ[res,$Failed]
(*If["returnCode"/.{opts}//TrueQ,
code,
ReleaseHold@code
]/;FreeQ[code,getHeldPlotCode|$Failed]*)
];
(de:diffEq[asc_])[type:"implicit",domain_List,opts___?OptionQ]/;implicitSolutionQ[de]:=Module[{res},
res=Catch@getHeldPlotCode[de,type,Automatic,domain,{opts}];
res=checkSol@runCode[res,"returnCode"/.Flatten@{opts}//TrueQ];
res/;FreeQ[res,$Failed]
(*If["returnCode"/.{opts}//TrueQ,
code,
ReleaseHold@code
]/;FreeQ[code,getHeldPlotCode|$Failed]*)
];
(de:diffEq[asc_])[type:"implicit",eqn_Equal,domain_List,opts___?OptionQ]/;implicitSolutionQ[de]:=Module[{res},
res=Catch@getHeldPlotCode[de,type,eqn,domain,{opts}];
res=checkSol@runCode[res,"returnCode"/.Flatten@{opts}//TrueQ];
res/;FreeQ[res,$Failed]
(*If["returnCode"/.{opts}//TrueQ,
code,
ReleaseHold@code
]/;FreeQ[code,getHeldPlotCode|$Failed]*)
];
(de:diffEq[asc_])["implicit plot",args___]:=de["implicit",args];*)


(* ::Input::Initialization:: *)
(*(*
 * Vector field / flow
 *)
(de:diffEq[asc_])[type:"flow"|"vector field",opts___?OptionQ]:=Module[{res},
res=Catch@getHeldPlotCode[de,type,Automatic,Automatic,{opts}];
res=checkSol@runCode[res,"returnCode"/.Flatten@{opts}//TrueQ];
res/;FreeQ[res,$Failed]
(*If["returnCode"/.{opts}//TrueQ,
code,
ReleaseHold@code
]/;FreeQ[code,getHeldPlotCode|$Failed]*)
];
(de:diffEq[asc_])[type:"flow"|"vector field",dom_List,opts___?OptionQ]:=Module[{res},
res=getHeldPlotCode[de,type,Automatic,dom,{opts}];
res=checkSol@runCode[res,"returnCode"/.Flatten@{opts}//TrueQ];
res/;FreeQ[res,$Failed]
(*If["returnCode"/.{opts}//TrueQ,
code,
ReleaseHold@code
]/;FreeQ[code,getHeldPlotCode|$Failed]*)
];
*)


(* ::Input::Initialization:: *)
(*(*
 * "Portrait": phase & direction portraits
 *)
(de:diffEq[asc_])[type:"portrait",opts___?OptionQ]:=Module[{res},
res=Catch@getHeldPlotCode[de,type,Automatic,Automatic,{opts}];
res=checkSol@runCode[res,"returnCode"/.Flatten@{opts}//TrueQ];
res/;FreeQ[res,$Failed]
(*If["returnCode"/.{opts}//TrueQ,
code,
ReleaseHold@code
]/;FreeQ[code,getHeldPlotCode|$Failed]*)
];
(de:diffEq[asc_])[type:"portrait",dom_List,opts___?OptionQ]:=Module[{code},
code=getHeldPlotCode[de,type,Automatic,dom,{opts}];
checkSol@runCode[code,"returnCode"/.Flatten@{opts}//TrueQ]
(*If["returnCode"/.{opts}//TrueQ,
code,
ReleaseHold@code
]/;FreeQ[code,getHeldPlotCode|$Failed]*)
];
*)


(* ::Input::Initialization:: *)
Begin["`diffEqDump`"];


(* getHeldPlotCode[]
getHeldPlotCode[de, type, plotexpressions, parameters, options]
parse plot and return plotting code
Throw[$Failed, diffEq] if unsuccessful ???
 Key: 	X dep var(s)
 	T indep var
 	X[t] solution curve(s)
*)


(* ::Input::Initialization:: *)
diffEq::"PlotPDE"="Error: Currently, plotting PDEs is not supported.";
diffEq::"IVar"="Error: Independed variable(s) `` expected to be a list of length 1.";
diffEq::PlotDim="Error: Plots of type `` not supported in dimension ``.";
diffEq::PlotIDim="Error: Dimension `` is not an integer between 1 and 3.";
diffEq::PlotType="Error: Plots of type `` not supported.";
diffEq::CantHappen="Bug: `` does the impossible: ``.";

(* getPlotter[dim, type]
*   get plotter for a plot of total dimension 1 to 3 of given type
*   Throws $Failed
 *)
getPlotter::usage="getPlotter[dim, type] gets plotting function for plot of dimension dim and type.";
$plotters=<|(* type \[Rule] <| dim \[Rule] plotter,.. |> *)
"solution"-><|"dim"->{2},2->Plot|>, (* replace "solution" by "plot" ??? *)
"plot"-><|"dim"->{2},2->Plot|>,
"parametric"-><|"dim"->{1,2,3},1->Plot,2->ParametricPlot,3->ParametricPlot3D|>,
"polar"-><|"dim"->{2},2->PolarPlot|>,
"flow"-><|"dim"->{1,2,3},1->vectorPlot1D,2->StreamPlot,3->VectorPlot3D|>,
"vector field"-><|"dim"->{1,2,3},1->vectorPlot1D,2->VectorPlot,3->VectorPlot3D|>,
"implicit"-><|"dim"->{2,3},2->ContourPlot,3->ContourPlot3D|>,
"portrait"-><|"dim"->{1},1->portrait1D|>,
"contact portrait"-><|"dim"->{3},3->(TBD@"plot"[##]&)|>
|>;
getPlotter[dim_Integer,type_]:=With[{plotters=
Lookup[
$plotters,
type,
$stack=Stack[];Message[diffEq::PlotType,type];Throw[$Failed,diffEq]
]},
Lookup[plotters,dim,Message[diffEq::CantHappen,getPlotter,Row[{{dim,type}," has no associated plotter."}]]]/;MemberQ[plotters["dim"],dim]
];
getPlotter[dim_Integer,type_]:=(
Message[diffEq::PlotDim,type,dim];
$stack=Stack[];
Throw[$Failed,diffEq]);
getPlotter[dim_,type_]:=(
Message[diffEq::PlotIDim,dim];
$stack=Stack[];
Throw[$Failed,diffEq]);

(* getVectorField[de, vf]
*   gets vector field(s) vf in terms of variables of de
*     suitable for StreamPlot/VectorPlot3D
*   if de is nonlinear, Solve[] may return than one vector field
 *)
(*call:*)getVectorField[de:diffEq[asc_],vf_]:=Module[{dvars,alldvars,orders,newvars,ivars,reduce1,reduce2},
ivars=Lookup[asc,"independentVars"];
dvars=Lookup[asc,"dependentVars"];
alldvars=Lookup[asc,"completeDependentVars"];
(*alldvars=Append[#,Replace[Last@#,{Derivative[n_][y_]\[RuleDelayed]Derivative[n+1][y],y_\[Rule]y'}]]&/@alldvars;*)
orders=Lookup[asc,"order"];
reduce1=stripArgs[dvars]@
Solve[
Lookup[asc,"de"],
MapThread[Derivative[Sequence@@#][#2][Sequence@@ivars]&,{orders,dvars}]
];
(*newvars=MapThread[Array[##,0]&,{Function/@Through[dvars[#]],orders}];
reduce2=Thread[Flatten@alldvars\[Rule]Flatten@newvars];*)
(*{vf/.reduce1/.reduce2,newvars,Reverse/@reduce2}*)
deReduce[de,vf/.reduce1]
];
(* diffEqClass`utilities`deReduce
*   deReduce[ode, expr]
*   Reduce derivatives dependent variables according to solving the ode 
*     for the highest order derivative(s)
 *)
deReduce::usage="deReduce[de, expr] reduces derivatives of dependent variables in expr according to solving the de for the highest order derivative(s).";
call:deReduce[de:diffEq[asc_],expr_]:=Module[{dvars,alldvars,orders,newvars,ivars,reduce1,reduce2},
ivars=Lookup[asc,"independentVars"];
dvars=Lookup[asc,"dependentVars"];
alldvars=Lookup[asc,"completeDependentVars"];
(*alldvars=Append[#,Replace[Last@#,{Derivative[n_][y_]\[RuleDelayed]Derivative[n+1][y],y_\[Rule]y'}]]&/@alldvars;*)
orders=Lookup[asc,"order"];
reduce1=
Solve[
Lookup[asc,"de"],
MapThread[Derivative[Sequence@@#][#2][Sequence@@ivars]&,{orders,dvars}]
];
If[Length@reduce1 >1,TBD["Reduction of derivatives in expressions by multiple-solution, nonlinear systems"]];
reduce1=Flatten@{reduce1,stripArgs[dvars]@reduce1};
(*newvars=MapThread[Array[##,0]&,{Function/@Through[dvars[#]],orders}];
reduce2=Thread[Flatten@alldvars\[Rule]Flatten@newvars];*)
(*{vvars/.reduce1/.reduce2,newvars,Reverse/@reduce2}*)
With[{ivars=ivars,dvars=dvars,reduce1=reduce1,orders=orders},
reduce2=Join[
MapThread[
With[{red=Derivative[Sequence@@#][#2][Sequence@@ivars]/.reduce1},
Derivative[n_/;n>First@#][#2][Sequence@@ivars]:>D[red,Sequence@@Transpose@{ivars,({n}-#)}]
]&,{orders,dvars}],
MapThread[
With[{red=Derivative[Sequence@@#][#2]/.reduce1},
Derivative[n_/;n>First@#][#2]:>(red/.#2->Derivative[n-First@#][#2])
]&,{orders,dvars}]
];
];
(*Flatten@{reduce1,reduce2};*)
expr//.Flatten@{reduce1,reduce2}
];

(*
 * Replace x \[Rule] x[0], x' \[Rule] x[1], etc
* Note that D, *Plot, *Plot3D etc will accept x', x'' etc as variables but
*   not both x and x' and so forth
 *)
varsToIndexedVars[vars_][expr_]:=varsToIndexedVars[expr,vars];
varsToIndexedVars[expr_,vars_]:=With[{v=Alternatives@@Flatten@{vars}},
expr/.{Derivative[n_][y:v]:>y[n],y:v:>y[0]}
];
indexedVarsToVars[vars_][expr_]:=indexedVarsToVars[expr,vars];
indexedVarsToVars[expr_,vars_]:=With[{v=Alternatives@@Flatten@{vars}},
expr/.{(y:v)[n_]:>Derivative[n][y]}
];


(* ::Input::Initialization:: *)
(* Paradigm:
getHeldPlotCode[
de:diffEq[asc_],
type:"solution"|"plot"|"parametric"|"flow"|"vector field"|"implicit"|"contact portrait"|Automatic,
dvars:_?VectorQ|{{_,_?NumericQ,_?NumericQ}..}|Automatic,
ivars:{t_}|{t_,t1_,t2_}|None|"autonomous"|Automatic,
opts_]:=code;
*)
(* PDE plots *)
getHeldPlotCode[de:diffEq[asc_],___]/;Length@Lookup[asc,"independentVars",{}]>1:=(
Message[diffEq::"PlotPDE"];
$stack=Stack[];
Throw[$Failed,diffEq]);
(* Generic plot the ODE
*  standard Plot[] of X[T]
 *)
(*getHeldPlotCode[de:diffEq[asc_],type:"solution"|"plot",Automatic,Automatic,opts_]/;implicitSolutionQ[de]:=... Make user explicitly request "implicit" since a numeric solution is normally possible ??? *)
getHeldPlotCode[
de:diffEq[asc_],type:"solution"|"plot"|"parametric"|"polar",
dep:Automatic|All,Automatic, (**)
opts_]:=
Module[{dvars,ivars,interval},
dvars=Switch[dep,
Automatic,Lookup[asc,"dependentVars"],
All,Lookup[asc,"completeDependentVars"],
_
,Message[diffEq::CantHappen,getHeldPlotCode,Row[{dep, " matches ", Automatic|All}]]
;Return[$Failed]
];
ivars=Lookup[asc,"independentVars"];
If[!MatchQ[ivars,{_}],
Message[diffEq::"IVar"];
$stack=Stack[]; (* for debugging ??? *)
Throw[$Failed,diffEq]];
interval=getDomain[de,(*"solution"*)type,ivars,opts];
getHeldPlotCode[de,type,dvars,interval,opts]
];
(* "parametric"|"polar" ??? *)
getHeldPlotCode[
de:diffEq[asc_],type:"solution"|"plot"|"parametric"|"polar",
dvars_List,{t_}, (**)
opts_]:=
Module[{interval},
interval=getDomain[de,(*"solution"*)type,{t},opts];
getHeldPlotCode[de,type,dvars,interval,opts]
];
getHeldPlotCode[
de:diffEq[asc_],type:"solution"|"plot"|"polar",
dvars_List,tint:{{t_,t1_,t2_}}, (**)
opts_]:=
Module[{plotlabel,code},
(* check dvars is a list of variables? *)
plotlabel=Lookup[asc,"title",None];
With[{plotter=getPlotter[2,type],solopts=DeleteCases["returnCode"->_]@opts},
code=Hold[plotter[Evaluate[#],##2]]&[
Through[dvars[t]]/.de["solution","particular","domain"->{{t1,t2}},Sequence@@solopts]//Unevaluated,
{t,t1,t2},
FilterRules[ (* PlotLegends instead of AxesLabel *)
Flatten@{opts,PlotLabel->plotlabel,PlotLegends->dvars},
Options@plotter]
]
]
];
(* "parametric" ??? *)
getHeldPlotCode[
de:diffEq[asc_],type:"parametric",
dvars_List,tint:{{t_,t1_,t2_}}, (**)
opts_]:=
Module[{plotlabel,axeslabel,dim,code},
(* check dvars is a list of variables? *)
plotlabel=Lookup[asc,"title",None];
dim=Length@dvars;
axeslabel=Switch[dim,
1,Join[{t},dvars],
_,dvars];
With[{plotter=getPlotter[dim,type],solopts=DeleteCases["returnCode"->_]@opts},
code=Hold[plotter[Evaluate[#],##2]]&[
Through[dvars[t]]/.de["solution","particular","domain"->{{t1,t2}},Sequence@@solopts]//Unevaluated,
{t,t1,t2},
FilterRules[Flatten@{opts,PlotLabel->plotlabel,AxesLabel->axeslabel},Options@plotter]
]
]
];


(* ::Input::Initialization:: *)
(*
 * ContourPlot of implicit solution
 *)
getImplicitEquation[de:diffEq[asc_]]:=Module[{sol,eq},
sol=toImplicitSolution@de@"solution";(* check sol exists ??? *)
    (* check number of solutions ??? *)
eq=Flatten[{sol/.(Solve|Inactive[Solve])[e_,__]:>e}]; (* check we have equations ??? *)
(* could Throw[$Failed,diffEq] *)
eq
];
getHeldPlotCode[de:diffEq[asc_],type:"implicit",Automatic,Automatic,opts_]:=
Module[{vars,interval,sol,eq},
eq=getImplicitEquation[de]; (* check we have equations ??? *)
vars=Join[Lookup[asc,"independentVars"],Lookup[asc,"dependentVars"]];
getHeldPlotCode[de,type,eq,vars,opts]
];
getHeldPlotCode[de:diffEq[asc_],type:"implicit",Automatic,vars_,opts_]:=
Module[{(*interval,*)eq},
eq=getImplicitEquation[de]; (* check we have equations ??? *)
getHeldPlotCode[de,type,eq,vars,opts]
];
getHeldPlotCode[de:diffEq[asc_],type:"implicit",eq_,vars_,opts_]:=
Module[{domain,plotlabel,code,eqn},
(* check we have equations in eq ??? *)
domain=getDomain[de,"flow",vars,opts];
plotlabel=Lookup[asc,"title",None];
With[{plotter=getPlotter[2,type]},
eqn=stripArgs[eq,domain[[All,1]]];
code=Hold[plotter[##]]&[
eqn,
Sequence@@domain,
FilterRules[
Flatten@{opts,PlotLabel->plotlabel,FrameLabel->Automatic},
Options@plotter]
]
]
];



(* ::Input::Initialization:: *)
(*
 * phase portrait of dvars
 *)

(*getHeldPlotCode[de:diffEq[asc_],type:"flow"|"vector field",Automatic,Automatic,opts_]:=
Module[{vf,allvars,dvars,ivars,interval,domain,rewriteIndexedFormalX},
allvars=Flatten@Lookup[asc,"completeDependentVars"];
If[!autonomousQ[de], (* add T to allvars *)
ivars=Lookup[asc,"independentVars"];
allvars=Join[ivars,allvars],
ivars={} (* don't add T and derivatives *)
];
dvars=Lookup[asc,"dependentVars"];
vf=getVectorField[de,Derivative[1]/@Flatten@allvars/.
(Derivative[1]@#\[Rule]1&/@ivars)];(* add derivative of ivars to vf *)
vf=varsToIndexedVars[vf,dvars];
(* domain ??? *)
domain=getDomain[de,type,allvars,opts];
domain=varsToIndexedVars[domain,dvars];
rewriteIndexedFormalX[x_]:=ToExpression[ToString[Unevaluated@x]<>ToString[#]]&;
Block[{\[FormalX]=rewriteIndexedFormalX@\[FormalX],\[FormalY]=rewriteIndexedFormalX@\[FormalY],\[FormalZ]=rewriteIndexedFormalX@\[FormalZ],\[FormalT]=Global`\[FormalT]\[FormalT]},(* $ex ??? *)
vf=vf;
domain=domain;
];
getHeldPlotCode[de,type,vf,domain,opts]
];*)
(*getHeldPlotCode[de:diffEq[asc_],type:"flow"|"vector field",Automatic,Automatic,opts_]:=
Module[{allvars,dvars,ivars,interval,domain,rewriteIndexedFormalX},
allvars=Flatten@Lookup[asc,"completeDependentVars"];
If[!autonomousQ[de], (* add T to allvars *)
ivars=Lookup[asc,"independentVars"];
allvars=Join[ivars,allvars]
];
domain=getDomain[de,type,allvars,opts];
getHeldPlotCode[de,type,Automatic,domain,opts]
];
call:getHeldPlotCode[de:diffEq[asc_],type:"flow"|"vector field",Automatic,dom:{{_,_?NumericQ,_?NumericQ}..},opts_]:=Module[{vf,dvars,ivars,interval,domain,rewriteIndexedFormalX},
dvars=Lookup[asc,"dependentVars"];
ivars=Lookup[asc,"independentVars"];
vf=getVectorField[de,Derivative[1]/@dom[[All,1]]/.
(Derivative[1]@#\[Rule]1&/@ivars)];
vf=varsToIndexedVars[vf,dvars];
domain=varsToIndexedVars[dom,dvars];
rewriteIndexedFormalX[x_]:=ToExpression[ToString[Unevaluated@x]<>ToString[#]]&;
Block[{\[FormalX]=rewriteIndexedFormalX@\[FormalX],\[FormalY]=rewriteIndexedFormalX@\[FormalY],\[FormalZ]=rewriteIndexedFormalX@\[FormalZ],\[FormalT]=Global`\[FormalT]\[FormalT]},(* $ex ??? *)
vf=vf;
domain=domain;
];
getHeldPlotCode[de,type,vf,domain,opts]
];
call:getHeldPlotCode[de:diffEq[asc_],type:"flow"|"vector field",vf_,dvars:{{_,_?NumericQ,_?NumericQ}..},opts_]:=
Module[{dim,ivar,plotlabel,code},
dim=Length@dvars;
(* Check dvars are among "completeDependentVars" and  "independentVars" ??? *)
(*dvars=Lookup[asc,"dependentVars"];*)
plotlabel=Lookup[asc,"title",None];
With[{plotter=getPlotter[dim,type]},
code=Hold[plotter[##]]&[
vf,
Sequence@@dvars,
FilterRules[Flatten@{opts,PlotLabel\[Rule]plotlabel},Options@plotter]
]
]
];*)


(* ::Input::Initialization:: *)
(*
 * parametric phase curve of dvars
 *)
(*getHeldPlotCode[de:diffEq[asc_],type:"parametric",Automatic,Automatic,ivars:{t_},opts_]:=Module[{},TBD[]];*)(* ="solution" above *)
getHeldPlotCode[de:diffEq[asc_],type:"parametric",dvars_?VectorQ,ivars:{t_},opts_]:=
Module[{ivar,tint,(*deOpts,*)trange},
(*ivar=Lookup[asc,"independentVars"];(*check same as t?*)*)
(*deOpts=Association@FilterRules[opts,Options@setupDiffEq];
trange=Lookup[deOpts,"domain",Lookup[asc,"domain",Automatic]]/.Automatic\[Rule]{0,1};*)
trange=getKey[de,"domain",opts];
tint=Join[{ivars},trange,2];
getHeldPlotCode[de,type,dvars,tint,opts]
];
getHeldPlotCode[de:diffEq[asc_],type:"parametric",dvars_?VectorQ,tint:{{t_,t1_,t2_}},opts_]:=
Module[{ivar,alldvars,plotlabel,dim},
(*ivar=Lookup[asc,"independentVars"];(*check same as t?*)*)
dim=Length@dvars;
plotlabel=Lookup[asc,"title",None];
With[{plotter=getPlotter[dim,type],solopts=DeleteCases["returnCode"->_]@opts},
Hold[plotter[Evaluate[#],##2]]&[
Through[dvars[t]]/.de["solution","domain"->{{t1,t2}},solopts]//Unevaluated,
{t,t1,t2},
FilterRules[Flatten@{opts,PlotLabel->plotlabel,AxesLabel->dvars},Options@plotter]
]
]
];

(* copy-paste dummy *)
getHeldPlotCode[de:diffEq[asc_],"dummy",opts_]:=Module[{dvars,ivars,alldvars,plotlabel},
dvars=Lookup[asc,"dependentVars"];
ivars=Lookup[asc,"independentVars"];
alldvars=Lookup[asc,"completeDependentVars"];
plotlabel=Lookup[asc,"title",None];
getHeldPlotCode[de,dvars,ivars]
];
(* until I can make up my mind :/ *)
getInactivePlotCode[args___]:=With[{code=getHeldPlotCode[args]},
code/.Hold[(f_)[a___]]:>Inactive[f][a]
];


(* ::Input::Initialization:: *)
(*(*
 * phase portrait of vf over dvars with automatic intervals
 *)
getHeldPlotCode[de:diffEq[asc_],type:"flow"|"vector field",Automatic,_,opts_]:=
Module[{dvars,alldvars},
dvars=Lookup[asc,"dependentVars"];
alldvars=Lookup[asc,"completeDependentVars"];
If[Length@Flatten@alldvars>3,
Message[diffEq::PlotDim,"Vector field plots",Length@Flatten@alldvars];
$stack=Stack[];
Throw[$Failed,diffEq]
];
(* if bounds on dvars in de, use them*)
(* if numeric solution, find bounds on dvars *)
(* otherwise find equilibria/singularities and bound them *)
(* if none, {0,1}^dim *)
(* pad the ranges and return *)
]
getHeldPlotCode[de:diffEq[asc_],type:"flow"|"vector field",vf_?VectorQ,ivars:{{_,_?NumericQ,_?NumericQ}..},_,opts_]:=
Module[{alldvars,dim,plotlabel,plotter,code},
alldvars=Lookup[asc,"completeDependentVars"];
dim=Length@Flatten@ivars;
If[dim>3,
Message[diffEq::PlotDim,"Vector field plots",Length@Flatten@alldvars];
$stack=Stack[];
Throw[$Failed,diffEq]
];
(*Switch[dim
,1,plotter=Inactive[Plot]
,2,plotter=Inactive[ParametricPlot]
,3,plotter=Inactive[ParametricPlot3D]
,n_Integer/;n>3,
Message[diffEq::PlotDim,"Parametric plots",dim]
;Throw[$Failed,diffEq]
,_,
Message[diffEq::PlotIDim,"Parametric plots",dim]
;Throw[$Failed,diffEq]
];*)
plotter=getPlotter[dim,type];
(* if bounds on dvars in de, use them*)
(* if numeric solution, find bounds on dvars *)
(* otherwise find equilibria/singularities and bound them *)
(* if none, {0,1}^dim *)
(* pad the ranges and return *)
];
getHeldPlotCode[de:diffEq[asc_],type:"flow"|"vector field",vf_?VectorQ,ivars_,opts_]:=
Module[{alldvars,plotlabel,tint},
(*alldvars=Lookup[asc,"completeDependentVars"];
If[Length@Flatten@alldvars>3,
Message[diffEq::PlotDim,"Vector field plots",Length@Flatten@alldvars];
Throw[$Failed,diffEq]*)
tint=getDomain[de,ivars,opts]; (* needs type ??? *)
getHeldPlotCode[de,type,vf,tint,opts]
(* if bounds on dvars in de, use them*)
(* if numeric solution, find bounds on dvars *)
(* otherwise find equilibria/singularities and bound them *)
(* if none, {0,1}^dim *)
(* pad the ranges and return *)
];*)


(* ::Input::Initialization:: *)
getHeldPlotCode[de:diffEq[asc_],type:"flow"|"vector field",
Automatic,Automatic,opts_]:=
Module[{allvars,dvars,ivars,interval,domain,rewriteIndexedFormalX},
allvars=Flatten@Lookup[asc,"completeDependentVars"];
If[!autonomousQ[de], (* add T to allvars *)
ivars=Lookup[asc,"independentVars"];
allvars=Join[ivars,allvars]
];
domain=getDomain[de,type,allvars,opts];
getHeldPlotCode[de,type,Automatic,domain,opts]
];
getHeldPlotCode[de:diffEq[asc_],type:"flow"|"vector field",
Automatic,dom:{{_,_?NumericQ,_?NumericQ}..},opts_]:=Module[{vf,dvars,ivars,interval,domain,rewriteIndexedFormalX},
dvars=Lookup[asc,"dependentVars"];
ivars=Lookup[asc,"independentVars"];
vf=getVectorField[de,Derivative[1]/@dom[[All,1]]/.
(Derivative[1]@#->1&/@ivars)];
vf=varsToIndexedVars[vf,dvars];
domain=varsToIndexedVars[dom,dvars];
rewriteIndexedFormalX[x_]:=ToExpression[ToString[Unevaluated@x]<>ToString[#]]&;
Block[{\[FormalX]=rewriteIndexedFormalX@\[FormalX],\[FormalY]=rewriteIndexedFormalX@\[FormalY],\[FormalZ]=rewriteIndexedFormalX@\[FormalZ],\[FormalT]=Global`\[FormalT]\[FormalT]},(* $ex ??? *)
vf=vf;
domain=domain;
];
getHeldPlotCode[de,type,vf,domain,opts]
];
getHeldPlotCode[de:diffEq[asc_],type:"flow"|"vector field",
vf_,dvars:{{_,_?NumericQ,_?NumericQ}..},opts_]:=
Module[{dim,ivar,plotlabel,code},
dim=Length@dvars;
(* Check dvars are among "completeDependentVars" and  "independentVars" ??? *)
(*dvars=Lookup[asc,"dependentVars"];*)
plotlabel=Lookup[asc,"title",None];
With[{plotter=getPlotter[dim,type]},
code=Hold[plotter[##]]&[
vf,
Sequence@@dvars,
FilterRules[Flatten@{opts,PlotLabel->plotlabel},Options@plotter]
]
]
];


(* ::Input::Initialization:: *)
(*getHeldPlotCode[de:diffEq[asc_],type:"portrait",
Automatic,dom_,opts_]:=
Module[{vf,allvars,dvars,ivars,interval,domain,rewriteIndexedFormalX},
dvars=Lookup[asc,"dependentVars"];
ivars=Lookup[asc,"independentVars"];
vf=getVectorField[de,Derivative[1]/@dom[[All,1]]/.
(Derivative[1]@#\[Rule]1&/@ivars)];
vf=varsToIndexedVars[vf,dvars];
getHeldPlotCode[de,type,vf,dom,opts]
];*)
getHeldPlotCode[de:diffEq[asc_],type:"portrait", (* combine with next *)
vf_,dom_,opts_]:=Module[{vf1,dvars,ivars,allvars,interval,domain,dim,code,rewriteIndexedFormalX,plotlabel},
dvars=Lookup[asc,"dependentVars"];
ivars=Lookup[asc,"independentVars"];
Switch[dom
,Automatic,(
allvars=Flatten@Lookup[asc,"completeDependentVars"];
(*allvars=Join[allvars,ivars];*)
domain=getDomain[de,"vector field",allvars,opts])
,_List,(
domain=getDomain[de,"vector field",dom,opts])
,_,(
Message[diffEq::CantHappen,"getHeldPlotCode[portrait]",Row[{"domain is ",dom}]];
Return[$Failed,getHeldPlotCode])
];
If[vf===Automatic,
vf1=getVectorField[de,Derivative[1]/@domain[[All,1]]/.
(Derivative[1]@#->1&/@ivars)],
vf1=vf
];
vf1=varsToIndexedVars[vf1,dvars];
domain=Join[domain,getDomain[de,"vector field",ivars,opts]];
domain=varsToIndexedVars[domain,dvars];
(*Print["vf1"\[Rule]vf1];
Print["domain"\[Rule]domain];*)
rewriteIndexedFormalX[x_]:=ToExpression[ToString[Unevaluated@x]<>ToString[#]]&;
Block[{\[FormalX]=rewriteIndexedFormalX@\[FormalX],\[FormalY]=rewriteIndexedFormalX@\[FormalY],\[FormalZ]=rewriteIndexedFormalX@\[FormalZ],\[FormalT]=Global`\[FormalT]\[FormalT]},(* for $ex ??? *)
vf1=vf1;
domain=domain;
];
(*Print["vf1"\[Rule]vf1];
Print["domain"\[Rule]domain];*)
dim=Length@dvars;(* dim of de without independent var *)
(* Check dvars are among "completeDependentVars" and  "independentVars" ??? *)
(*dvars=Lookup[asc,"dependentVars"];*)
plotlabel=Lookup[asc,"title",None];
With[{plotter=getPlotter[dim,type]},
code=Hold[plotter[##]]&[
vf1,(* change to de with args stripped ??? *)
Sequence@@domain,
FilterRules[Flatten@{opts,PlotLabel->plotlabel},Options@plotter]
]
]
];
(*getHeldPlotCode[de:diffEq[asc_],type:"portrait",
vf_,dvars:{{_,_?NumericQ,_?NumericQ}..},opts_]/;autonomousQ[de]:=
Module[{dim,ivar,plotlabel,code},
dim=Length@dvars-1;(* dim of de without independent var *)
(* Check dvars are among "completeDependentVars" and  "independentVars" ??? *)
(*dvars=Lookup[asc,"dependentVars"];*)
plotlabel=Lookup[asc,"title",None];
With[{plotter=getPlotter[dim,type]},
code=Hold[plotter[##]]&[
vf,(* change to de with args stripped ??? *)
Sequence@@dvars,
FilterRules[Flatten@{opts,PlotLabel\[Rule]plotlabel},Options@plotter]
]
]
];*)


(* ::Input::Initialization:: *)
getHeldPlotCode[de:diffEq[asc_],type:"contact", 
vf_,dom_,opts_]:=TBD["contact portrait"]; (* TBD ??? *)



(* ::Input::Initialization:: *)
End[];(* "`diffEqDump`" *)


(* ::Input::Initialization:: *)
Begin["`helpDump`"];


(* ::Input::Initialization:: *)
(* make keys plural when appropriate *)
$help=<|
"variables"->"Use simple symbols, such as single letters x, y, t -- or short words/identifiers, position, time, x1, x2 -- for variables. Many functions in Mathematica allow more complicated expressions for variables, but this package does not support such forms.",
"equations"->"Equations use a double equal sign \"==\" that the system often rewrites as a single double-equal character \"==\".  A single equal sign \"=\" is an assignment.  A common mistake is to write \"y'[x]=y[x]\" instead of \"y'[x]==y[x]\".  Once made, the mistake is hard to find.  The mistake can be corrected by executing \"y'[x]=.\", \"Clear[Derivative]\", or quitting the kernel from the Evaluation menu (see \"kernel\").",
"kernel"->"Mathematica consists of two connnected applications, the kernel and the front end.  The kernel is responsible for carrying out computations when code is executed.  You can quit the kernel from the Evaluation menu.  The front end will not quit but will automatically restart a new kernel.  Beware, you will lose all the definitions that you have made during the session, but you can make them again.  Sometimes it is the easiest way to reset the system.  See also \"front end\", \"crash\".",
"front end"->"Mathematica consists of two connnected applications, the kernel and the front end.  The front end is responsible for typesetting and displaying the results of computations when code is executed.  It also handles dynamically updated objects like animations and Manipulate demos.  You can quit the front end from the Mathematica menu.  This will quit the kernel, too.  See also \"kernel\", \"crash\".",
"crashes"->"Mathematica is a complicated system.  While fairly stable, it can suddenly stop working.  In computer lingo, it can crash.  Either the kernel or the front end can crash.  If the kernel crashes, it is like quitting the kernel, except the front end will beep; you lose all your definitions.  If the front end crashes, Mathematica quits without saving.  \!\(\*
StyleBox[\"You\",\nFontWeight->\"Bold\"]\)\!\(\*
StyleBox[\" \",\nFontWeight->\"Bold\"]\)\!\(\*
StyleBox[\"lose\",\nFontWeight->\"Bold\"]\)\!\(\*
StyleBox[\" \",\nFontWeight->\"Bold\"]\)\!\(\*
StyleBox[\"all\",\nFontWeight->\"Bold\"]\)\!\(\*
StyleBox[\" \",\nFontWeight->\"Bold\"]\)\!\(\*
StyleBox[\"your\",\nFontWeight->\"Bold\"]\)\!\(\*
StyleBox[\" \",\nFontWeight->\"Bold\"]\)\!\(\*
StyleBox[\"work\",\nFontWeight->\"Bold\"]\) and edits, if any, made to the notebooks you were using.  Save your work often.  See also \"kernel\", \"front end\".",
"assignments"->Row[{"An assignment defines a value for a function or variable.  Assignments may be made with either a single equal sign \"=\" (see ",Button[TextCell[Style["Set", "Input"]], Inherited, BaseStyle -> "Link", ButtonData -> "paclet:ref/Set"]," in Wolfram Documentation) or colon-equals \":=\" (see ",Button[TextCell[Style["SetDelayed", "Input"]], Inherited, BaseStyle -> "Link", ButtonData -> "paclet:ref/SetDelayed"]," in Wolfram Documentation).  Normally variable assignments use \"=\", and function definitions use \":=\".  Mastering the technical differences of them is not a goal of this course."}]
|>;


(* ::Input::Initialization:: *)
$synonyms=AssociationThread[Keys[$help]->Keys[$help]]~Join~
<|
(* handle singular forms with Pluralize[] (?) *)
(*"variable"\[Rule]"variables",
"equation"\[Rule]"equations",*)
"ode"->"equations",
"de"->"equations",
"diff eq"->"equations",
"set"->"assignments"
|>;
With[{nf=Nearest@Keys@$synonyms},
$findhelp=DeleteDuplicates@Lookup[$synonyms,nf[##]]&
];


(* ::Input::Initialization:: *)
help[diffEq]:="setupDiffEq[] is the way to create a diffEq[] object. The form de = setupDiffEq[equations, y, x] is one of the ways to specify the ODE and boundary conditions.

Once you have set up a diffEq[] object de with de = setupDiffEq[], you can evaluate it de[1.2], plot it de[\"plot\"], or get the solution de[\"solution\"].  There are other commands:
	diffEq[<number>] \[LongDash] evaluate the solution at a number
	diffEq[\"solution\"] \[LongDash] return an exact or numerical solution
	diffEq[\"exact\"] \[LongDash] return the exact solution, if possible
	diffEq[\"numerical\"] \[LongDash] return a numerical solution
	diffEq[\"plot\"] \[LongDash] plot solution(s)
	diffEq[\"parametric\"] \[LongDash] plot curve parametrized
	diffEq[\"implicit\"] \[LongDash] plot solution given in implicit form
	diffEq[\"flow\"] \[LongDash] plot the phase flow (phase portrait)
	diffEq[\"vector field\"] \[LongDash] plot the phase vector field
	diffEq[\"portrait\"] \[LongDash] full portrait of a first-order autonomous ODE

Use help[diffEq[<cmd>]] to get help for a specific command."; 
help[setupDiffEq]:="setupDiffEq[] is the way to create a diffEq[] object. There are several ways to specify the ODE system.
	de = setupDiffEq[equations, y, x]
	de = setupDiffEq[equations, y, {x, x1, x2}]
	de = setupDiffEq[DSolve[equations, y, x]]
	de = setupDiffEq[NDSolve[equations, y, {x, x1, x2}]]";


(* ::Input::Initialization:: *)
helpinit[]:=(
Pluralize["variable"];(* initialize word indices *)
helpinit[]=True);
help[keyword_String]/;helpinit[]:=$help@First@$findhelp@"keyword"; (* check keyword agrees with $findhelp ??? *)
help/:(de:diffEq[asc_])[good___,help,bad___]:=Module[{cmd,gd,bd},
gd=Hold[good];
If[Length[gd]>1,
cmd=gd[[{1}]];
gd=Rest@gd,
If[Length@bd >1,
cmd=bd[[{1}]];
bd=Rest@bd,
cmd=Hold[]
]
];
help[de,cmd,gd,bd]
];
help[(de:diffEq[asc_])[cmd_String,args___]]:=help[de,cmd,{args},{}];
(*
 * Parse if possible the help depending on arguments the user thinks
*   thinks are good and bad
 *)
help[de:diffEq[asc_],cmd_String,good_,bad_]:=Module[{},
"No help yet ???"/;False];


(* ::Input::Initialization:: *)
(* tell the user about the command as it relates to de
*   what's the difference between this and help
*     help should analyze errors
*     about tells what an error free cmd does
 *)
SetAttributes[about,HoldAll];
about[diffEq]:=help[diffEq];
about[]:=lastcall;(*Module[{history=Reverse@DownValues@In},
Cases[history,HoldPattern[Verbatim[HoldPattern][_]]\[RuleDelayed]diffEq[_][___],1]
];*)
call:about[(de:diffEq[asc_])[cmd_String,args___]]:=Module[{},
HoldForm[call]/;False];


(* ::Input::Initialization:: *)
End[];(*`helpDump`*)


(* ::Input::Initialization:: *)
Begin["`diffEqDump`"];


(* ::Input::Initialization:: *)
LieD[vector_,vars_][expr_]:=D[expr,{vars}].vector;
LieDerivative[Function[body_List]]:=LieDerivative[Function[body],Length@Unevaluated@body];
LieDerivative[vectorFN_,dim_][f_]:=With[{vars=Array[Slot,dim]},
Evaluate[LieD[vectorFN@@vars,vars][f@@vars]]&];


(* ::Input::Initialization:: *)
totalD[{x_,y_,n_,f_}][expr_]:=With[{vars=Table[y[k],{k,0,n}]},
Join[{1},Rest@vars].D[expr,{Join[{x},Most@vars]}]/.y[n]->f@@Join[{x},Most@vars]
];


(* ::Input::Initialization:: *)
End[];(*"`diffEqDump`"*)


(* ::Input::Initialization:: *)
Begin["`diffEqDump`"];


(* ::Input::Initialization:: *)
End[];(* "`diffEqDump`" *)


(* ::Input::Initialization:: *)
Begin["`diffEqDump`"];


(* ::Input::Initialization:: *)
(* plot separatrices (2x2 real system only) *)
ClearAll[plotSeparatrices,getStoppingEvents];
SetAttributes[getStoppingEvents,Listable];
(* default value: need x, y, t variable names so we create a Function template *)
Options@getStoppingEvents={
"Variables"->{#1,#2,#3},(* syntax: "Variables"\[Rule]{x,y,t} *)
"Equilibrium"->{0.,0.},
"BoundingBox"->{{-1.,1.},{-1.,1.}}}; (* syntax: "BoundingBox"\[Rule]{{x[t],x1,x2},{y[t],y1,y2}} *)
getStoppingEvents::badcrit="\"StoppingCriterion\" `` not of \"BoundingBox\", \"Norm\"\[Rule]n, \"Condition\"->criteria. Criterion ignored.";
getStoppingEvents[crit_,opts:OptionsPattern[]]:=With[
{vars=Most@OptionValue["Variables"],varst=OptionValue["Variables"]/.{x_,y_,t_}:>{x[t],y[t]}},
Switch[crit,
"BoundingBox"|Automatic
,WhenEvent[#,"StopIntegration"]&/@(Abs[#1-Mean[{#2,#3}]]==(#3-#2)/2&@@@MapThread[Prepend,{OptionValue["BoundingBox"],varst}]),
"Norm"->_?NumericQ
,WhenEvent[#,"StopIntegration"]&@(Norm[varst-OptionValue["Equilibrium"]]==Last@crit),
"Condition"->_List
,getStoppingEvents[#,opts]&/@Last@crit,
"Condition"->_
,WhenEvent[#,"StopIntegration"]&@(Last@crit/.Thread[varst->varst]~Join~Thread[vars->varst] (* explanation? *)
),
_
,
Message[getStoppingEvents::badcrit,crit];
{}
]/;Length@OptionValue["Variables"]==3 (* TBD: error message *)
];
Options@plotSeparatrices={"StoppingCriterion"->"BoundingBox"};
plotSeparatrices[F_,xi:{x_,x1_,x2_},yi:{y_,y1_,y2_},eq_,OptionsPattern[]]:=Module[{(*evecs,evals,*)esys,vars,t,stopevents,sep},
(* TDB: check syntax of varspec *)
(* TBD: check length of varspec equals length of eq *)
vars={x,y};
(*{evals,evecs}=*)murf=esys=Eigensystem[D[F,{vars}]/.Thread[vars->eq]//N];
If[MatchQ[esys[[1,1]],_Complex],esys={}];
stopevents=getStoppingEvents[Flatten@List@OptionValue["StoppingCriterion"],
"Variables"->{x,y,t},
"Equilibrium"->eq,
"BoundingBox"->{{x1,x2},{y1,y2}}
];
If[stopevents==={},(* happens if user messes up; return nothing? *)
stopevents=getStoppingEvents[Automatic,
"Variables"->{x,y,t},
"Equilibrium"->eq,
"BoundingBox"->{{x1,x2},{y1,y2}}
]
];
sep=Flatten[
Quiet[
MapThread[
Function[{eval,evec},
{NDSolveValue[
Rationalize[
{D[Through[vars@t],t]==(F/.v:Alternatives@@vars:>v[t]),
Through[vars@0]==eq+Sqrt@$MachineEpsilon*evec,
stopevents},
0],
vars,
{t,0,Sign[eval]Infinity},WorkingPrecision->32],
NDSolveValue[
Rationalize[
{D[Through[vars@t],t]==(F/.v:Alternatives@@vars:>v[t]),
Through[vars@0]==eq-Sqrt@$MachineEpsilon*evec,
stopevents},
0],
vars,
{t,0,Sign[eval]Infinity},WorkingPrecision->32]}
],
esys],
{NDSolveValue::ndsz,LinearSolve::nosol}],
1];
sep=DeleteCases[sep,sol_?(!FreeQ[#,NDSolveValue]&)];
Graphics@Map[
Function[{sol},
Arrow@Transpose@Through[sol@"ValuesOnGrid"]
],
sep
]
];


(* ::Input::Initialization:: *)
ClearAll[stabilityTrajectories];
SetAttributes[stabilityTrajectories,HoldFirst];
stabilityTrajectories[F_,xi:{x_,x1_,x2_},yi:{y_,y1_,y2_},eq_List,rad_,rstab_,npts_:12]:=Module[{state,newstate,t,stable=0},
state=First@NDSolve`ProcessEquations[{{x'[t],y'[t]}==(F/.{z:_[t]:>z,v:x|y:>v[t]}),
Thread[{x[0],y[0]}==eq],
getStoppingEvents[{"BoundingBox","Norm"->rstab/1*^4},
"Variables"->{x,y,t},
"Equilibrium"->eq,
"BoundingBox"->{{x1,x2},{y1,y2}}
]},
{x,y},
{t,0,Infinity},MaxSteps->1000];
Graphics[{
Table[
{First@p,(*color*)
Point@Last@p,
newstate=First@NDSolve`Reinitialize[state,Thread[{x[0],y[0]}==Last@p]];
Quiet[NDSolve`Iterate[newstate,Infinity],NDSolve`Iterate::mxst];
With[{xy=Through[Values[NDSolve`ProcessSolutions[newstate]]["ValuesOnGrid"]]},
stable+=Total@UnitStep[Total[xy^2]-rstab^2];
Line@Transpose@xy
]},
{p,Transpose@{ColorData[97]/@Range@npts,CirclePoints[eq,rad,npts]}}
],
Gray,Circle[eq,rad],If[stable==0,Darker@Green,Red],Thick,Circle[eq,rstab],Point[eq]
}]
]


(* ::Input::Initialization:: *)
$diffEqDemos=<|
"equilibrium"->equilibriumDemo,
"lyapunov"->lyapunovFunctionExplorer,
"lyapunov3d"->lyapunovFunctionExplorer3D,
"stability"->({"equilibrium","lyapunov","lyapunov3d"}&) (* class of demos *)
|>;
$demoThesaurus=AssociationThread[Keys@$diffEqDemos->Keys@$diffEqDemos]~Join~
<|
(*"equilibrium"\[Rule]"equilibrium",*)
"criticalpoint"->"equilibrium",
(*"lyapunov"\[Rule]"lyapunov",*)
"liapunov"->"lyapunov",
(*"lyapunov3d"\[Rule]"lyapunov3d",*)
"liapunov3d"->"lyapunov3d"(*,
"stability"\[Rule]"stability"*)
|>;
diffEqDemo::usage::"diffEqDemo[demo] invokes the demonstration named demo.";
diffEqDemo[]:=Keys[$diffEqDemos];
diffEqDemo[s_String]:=With[{res=Lookup[
$diffEqDemos,
getSynonym[$demoThesaurus,s], (* TBD: check ??? *)
Message[diffEqDemo::notent,s,diffEqDemo];$Failed]},
Replace[res[],Except[_List]->Null]/;FreeQ[res,$Failed]];


(* ::Input::Initialization:: *)
(*Begin["Global`"];*)
equilibriumDemo[]:=CreateDocument[{
TextCell["Equilibrium stability demo","Section"],
TextCell["Enter a vector field F in terms of x and y.  The demo assumes the origin to be an equilibrium.  The stability target defines the given neighborhood in which the trajectories from the neighborhood defined by radius should remain.  If for every stability target, it is possible to find a radius such that the trajectories remain within the stability target, the origin is a stable equilibrium. Separatrices will be shown when appropriate.","Text"],
ExpressionCell[
Manipulate[
With[{
vf=vplotter[RotationMatrix[t0].F,{x,-2,2},{y,-2,2},VectorStyle->LightGray,StreamStyle->LightGray]},
Dynamic@Quiet[
Show[
vf,
plotSeparatrices[RotationMatrix[theta].F,{x,-2,2},{y,-2,2},{0.,0.},"StoppingCriterion"->"Norm"->rad],
stabilityTrajectories[RotationMatrix[theta].F,{x,-2,2},{y,-2,2},{0.,0.},rad,rstab,pts],
PlotLabel->Row[{
"Eigenvalues = ",
SetPrecision[Chop@Eigenvalues[
D[RotationMatrix[theta].F,{{x,y}}]/.Thread[{x,y}->{0,0}]
],3]
}]
],
{General::munfl,NDSolveValue::mxst}]
],
Row[{
Control@{{F,{-y,2x},"F"},InputField,TrackingFunction->((F=#;theta=0.)&)},
Control@{{vplotter,VectorPlot,""},{VectorPlot,StreamPlot}},
" ",
Control@{{update,False,"update"},{False,True},
TrackingFunction->((update=#;If[TrueQ@update,t0=theta,t0=0.])&)}
}],
{{theta,0.,"perturb"},-0.4,0.4,
TrackingFunction->((theta=#;If[TrueQ@update,t0=theta])&),
Appearance->"Labeled"},
{state,None},{{t0,0.},None},{{eq,{0.,0.}},None},
{{rad,0.75,"radius"},0.05,1.5},
{{rstab,1.5,"stability target"},0.1,1.9},
{{pts,12,"points"},6,25,1},
Bookmarks->{
"node 1 (asymptotically stable)":>(F={-2x,-3y};theta=0.;pts=20),
"node 2 (unstable)":>(F={2x,3y};theta=0.;pts=24),
"saddle 1 (unstable)":>(F={-2x+y,3y-x};theta=0.;pts=20),
"saddle 2 (unstable)":>(F={-2 x+y,-x-x^2+3 y-(5 y^2)/4};theta=0.;pts=25),
"center 1 (stable)":>(F={-y,2x};theta=0.;pts=12),
"spiral 1 (asymptotically stable)":>(F={-x+5 y,-2 x};theta=0.;pts=12),
"spiral 2 (unstable)":>(F=-{-x-y,x-y};theta=0.;pts=12),
"spiral 3 (asymptotically stable)":>(F={-x+y,-x-y+2 y^2};theta=0.;rad=0.75;pts=16),
"border case 1":>(F={-x,-3x-y};theta=0.;pts=12),
"border case 2":>(F={2 x-y,x};theta=0.;pts=25),
"border case 3":>(F={-x,-3x-x^2-y+(2 y^2)/3};theta=0.;pts=12)}
],
"Output",
CellContext->"diffEqClass`diffEqDump`"
]
},
WindowTitle->"Equilibrium stability demo",
StyleDefinitions->FrontEnd`FileName[{"diffEqClass"},"Diff Eq Style.nb",CharacterEncoding->"UTF-8"]];
(*End[];*) (* "Global`" *)


(* ::Input::Initialization:: *)
lyapunovFunctionExplorer[]:=CreateDocument[{
TextCell["Lyapunov function explorer","Section"],
TextCell["Try to find the coefficients {a,b} and the angle t that make E\[ThinSpace]=\[ThinSpace]a(c\[ThinSpace]x+s\[ThinSpace]y)^2+b(c\[ThinSpace]y-s\[ThinSpace]x)^2 a Lyapunov function.  The function E and dE/dt may be viewed underlying the phase flow by clicking on the contourplot selector.  The color green indicates dE/dt\[ThinSpace]<\[ThinSpace]0 and red indicates dE/dt\[ThinSpace]>\[ThinSpace]0.  In the contour plot for E, one can tell the rate of change of E along the flow by how the flow crosses the contour lines. If there exists a setting that creates a function E such that the critical point in the center is surrounded by green, then the critical point is stable.","Text"],
ExpressionCell[
Manipulate[
Pane[
With[{sp=StreamPlot[F,{x,-2,2},{y,-2,2},
StreamScale->Tiny,
StreamColorFunction->Function[{x,y,vx,vy,speed},ColorData["RedGreenSplit"]@UnitStep[-Derivative[1,0][quadE[evs,t]][x,y]vx-Derivative[0,1][quadE[evs,t]][x,y]vy+10^-3]],
StreamColorFunctionScaling->False
]},
Legended[
Show[
ControlActive[Graphics[{},Options[sp]],
Switch[contourplot,
None
,Graphics[{},Options[sp]],
"E"
,ContourPlot[quadE[evs,t][x,y],
{x,-2,2},{y,-2,2},
Contours->15,ContourStyle->Gray,
ColorFunction->(Directive[Opacity[0.3],ColorData["M10DefaultDensityGradient"][#]]&)],
"dE/dt"
,ContourPlot[{Derivative[1,0][quadE[evs,t]][x,y],Derivative[0,1][quadE[evs,t]][x,y]}.F,
{x,-2,2},{y,-2,2},
ContourStyle->Gray,
ColorFunction->(Directive[Opacity[0.3],ColorData["RedGreenSplit"][Clip[0.5-#,{0,1}]]]&),
ColorFunctionScaling->False
]
]
],
sp,
Graphics[Point[{0,0}]]],
SwatchLegend[ColorData["RedGreenSplit"]/@{0,1},{"dE/dt > 0 (unstable)","dE/dt < 0 (stable)"}]
]
],
{500,350}],
{{F,-{-y,x+y}},InputForm},
{{evs,{1,2}},InputForm},
{t,0,2.Pi},
{{contourplot,None},{None,"E","dE/dt"}},
Initialization:>(
quadE[evs_,theta_]:=Function[{x,y},{x,y}.
RotationMatrix[-theta].DiagonalMatrix[evs].RotationMatrix[theta].{x,y}];
),
Bookmarks->{
"rotate 1":>(F={y,-x-y-2 y^2};evs={1,2};t=6.2;contourplot="dE/dt"),
"valentine 1":>(F={-2x y,x^2-y^3};evs={1,1};t=0.;contourplot="dE/dt")
}
],
"Output",
CellContext->"diffEqClass`diffEqDump`"]
},
WindowTitle->"Lyapunov Explorer",
StyleDefinitions->FrontEnd`FileName[{"diffEqClass"},"Diff Eq Style.nb",CharacterEncoding->"UTF-8"]];


(* ::Input::Initialization:: *)
lyapunovFunctionExplorer3D[]:=CreateDocument[{
TextCell["Lyapunov function explorer 3D","Section"],
TextCell["Try to find the coefficients {a,b} and the angle t that make E\[ThinSpace]=\[ThinSpace]a(c\[ThinSpace]x+s\[ThinSpace]y)^2+b(c\[ThinSpace]y-s\[ThinSpace]x)^2 a Lyapunov function.  The 3D surface represents the function E and phase flow is projected from the phase plane onto the surface.  The color green indicates dE/dt\[ThinSpace]<\[ThinSpace]0 and red indicates dE/dt\[ThinSpace]>\[ThinSpace]0. If there exists a setting that creates a function E such that the critical point in the center is surrounded by green, then the critical point is stable.","Text"],
ExpressionCell[
Manipulate[
Pane[
With[{flow=Cases[StreamPlot[{y,-x-y},{x,-2,2},{y,-2,2},
StreamScale->Tiny],Arrow[p_]:>p,Infinity]},
With[{flowCA=flow[[;;;;2]]},
Legended[
Dynamic[
ControlActive[
Graphics3D[{Arrowheads[Small],Thickness[Medium],
{Function[{x0,y0},ColorData["RedGreenSplit"]@UnitStep[-{Derivative[1,0][quadE[evs,t]][x,y],Derivative[0,1][quadE[evs,t]][x,y]}.F+10^-3/.{x->x0,y->y0}]]@@First[#],
Line[{##,quadE[evs,t][##]}&@@@#]
}&/@flowCA,
Thin,Line[
Table[
Append[#,quadE[evs,t]@@# ]&[{1.,u}.pv],
{pv,Transpose[{#,Differences[Append[#,First@#]]}]&@{{-2.,-2.},{2.,-2.},{2.,2.},{-2.,2.}}},{u,Subdivide[0.,1.,20]}
]],
Point[{0,0,0}]
},Options[Plot3D,BoxRatios]],
Show[
Plot3D[quadE[evs,t][x,y],
{x,-2,2},{y,-2,2},
MeshFunctions->{Function[{x0,y0},-{Derivative[1,0][quadE[evs,t]][x,y],Derivative[0,1][quadE[evs,t]][x,y]}.F+10^-3/.{x->x0,y->y0}],#3&},MeshShading->{Thread[Directive[Opacity[0.3],ColorData["RedGreenSplit"]/@{0,1}]]},Mesh->{{0},15}],
Graphics3D[{Arrowheads[Small],
{Function[{x0,y0},ColorData["RedGreenSplit"]@UnitStep[-{Derivative[1,0][quadE[evs,t]][x,y],Derivative[0,1][quadE[evs,t]][x,y]}.F+10^-3/.{x->x0,y->y0}]]@@First[#],
Arrow[{##,quadE[evs,t][##]}&@@@#],
Opacity[0.3],
Arrow@PadRight[#,{Automatic,3},0.]
}&/@flow
}],
Graphics3D[Point[{0,0,0}]]]
](*,
TrackedSymbols\[RuleDelayed]{evs,t}*)],
SwatchLegend[ColorData["RedGreenSplit"]/@{0,1},{"dE/dt > 0 (unstable)","dE/dt < 0 (stable)"}]
]
]],
{500,350}],
{{F,-{-y,x+y}},InputForm},
{{evs,{1,2},Dynamic@ssqlabel},InputForm,TrackingFunction->(If[ListQ@#&&Length@#==2&&AllTrue[#,Positive],
evs=#;ssqlabel="ssq coefficients",ssqlabel="two positive numbers"]&)},
{{t,0.,"rotate"},0,2.Pi},
{{contourplot,None},None},
{{ssqlabel,"ssq coefficients"},None},
Initialization:>(
quadE[evs_,theta_]:=Function[{x,y},{x,y}.
RotationMatrix[theta].DiagonalMatrix[evs].RotationMatrix[-theta].{x,y}];
),
Bookmarks->{
"rotate 1":>(F={y,-x-y-2 y^2};evs={1,2};t=6.2;contourplot="dE/dt"),
"valentine 1":>(F={-2x y,x^2-y^3};evs={1,1};t=0.;contourplot="dE/dt")
}
],
"Output"(*,
CellContext\[Rule]"diffEqClass`diffEqDump`"*)]
},
WindowTitle->"Lyapunov Explorer 3D",
Saveable->False,
StyleDefinitions->FrontEnd`FileName[{"diffEqClass"},"Diff Eq Style.nb",CharacterEncoding->"UTF-8"]];


(* ::Input::Initialization:: *)
End[];(*"`diffEqDump`"*)


(* ::Input::Initialization:: *)
Begin["`diffEqDump`"];


(* ::Input::Initialization:: *)
(* find integer matrices with integer eigenvalues *)
ClearAll[findIMIE,jordanBlock,invalidmatrixQ];
Options[findIMIE]={
"RandomSeed"->0,
MaxIterations->Automatic,
"Nonsingular"->Automatic,
(*"JordanDecomposition"\[Rule]Automatic,(* list of block sizes *)*)
"MaxEntry"->Automatic,(* max matrix entry of A *)
"MaxEigenvalue"->Automatic,(* max eigenvalue of A *)
"MaxIterations"->Automatic, (* max number of random tries *)
"MaxRepeatedEigenvalue"->Automatic}; (* TBD: 
										maximum algebraic multiplicity
										of eigenvalues of A *)
(* constructs Jordan block with diagonal \[Lambda] and superdiagonal m *)
jordanBlock[1,\[Lambda]_,m_]:=\[Lambda]*IdentityMatrix[1];
jordanBlock[dim_,\[Lambda]_,m_]:=\[Lambda]*IdentityMatrix[dim]+DiagonalMatrix[ConstantArray[m,dim-1],1];
(* determines whether a matrix meets user constraints *)
invalidmatrixQ[rank_,maxeigenval_][m_?MatrixQ,det_Integer]:=(*!TrueQ[MatrixRank[m]\[Equal]rank]*)det==0&&maxeigenval>det/2;
invalidmatrixQ[rank_,maxeigenval_][m_,det_]:=True;
(*diffEq::noev="\"MaxEigenvalue\" too small";*)
(* findIMIE find integer matrices with integers eigenvalues (IMIE)
*  findIMIE[d] returns a diagonalizable IMIE
*  findIMIT[{d1, d2,...}] returns an IMIE with Jordan blocks of sizes d1, d2, etc
*  findIMIE[{{d1,n1},...}] return an IMIE with a repeated Jordan block
*  findIMIE[d, n] returns n IMIEs
 *)
findIMIE[d_Integer|d:{__Integer},n_Integer:1,OptionsPattern[]]:=
With[{dims=Replace[d,k_Integer:>ConstantArray[1,k]]},
BlockRandom@
Module[{det,diag,pp,aa,dim,blockmat,maxentry,maxev,iter,maxiter,res},
SeedRandom[OptionValue["RandomSeed"]];
dim=Total@dims; (* dimension of matrices *)
maxentry=OptionValue["MaxEntry"]/.Automatic->Max[2,Floor[8/dim]];
maxev=OptionValue["MaxEigenvalue"]/.Automatic->10;
res={}; (* accumulates results *)
iter=0;
maxiter=OptionValue[MaxIterations]/.Automatic->Max[100,2n];
While[
Length@res<n&&iter<maxiter,
iter++;
(* get a valid transition matrix *)
While[invalidmatrixQ[dim,maxev][pp,det],pp=RandomInteger[{-1,1}maxentry,{dim,dim}];
det=Abs@Det[pp];
db["temp DET = ", det];
];
db["DET = ", det];
If[det!=0,(* unnecessary consistency check *)
diag=RandomChoice[ (* get eigenvalues *)
If[TrueQ@Not@OptionValue["Nonsingular"],DeleteCases[#,0],#]&@Range[ (* XXX Need to fix empty list *)
Mod[RandomInteger[{Ceiling[-det/2],Ceiling[det/2]}],det,-maxev],maxev,
det],
Length@dims](*RandomInteger[{Ceiling[-det/2],Ceiling[det/2]}]+det*RandomInteger[{-1,1}Max[1,Floor[10/det]],Length@dims]*);
(* construct Jordan block form *)
blockmat=LinearAlgebra`BlockDiagonalMatrix[
Table[
jordanBlock[
dims[[k]],
diag[[k]],
det*RandomChoice[DeleteCases[Apply[Range][{-1,1}Max[1,Floor[10/det]]],0]]
],
{k,Length@dims}]
](*RandomInteger[{Ceiling[-det/2],Ceiling[det/2]}]+det*RandomInteger[{-1,1}Max[1,Floor[10/det]],dim]*);
db["DEBUG ",{d,dims,MatrixForm@blockmat}];
(* result = conjugated block form *)
aa=pp.blockmat.Inverse[pp],
db["DEBUG ",{MatrixRank[pp],det}];
aa=$Failed
];
If[FreeQ[aa,$Failed],
(* add result if not present *)
res=DeleteDuplicates[Append[res,aa]]
]
];
If[Length@res<n,Print["MaxIterations"]]; (* XXX TBD *)
If[n==1,First@res,res]
]];


(* ::Input::Initialization:: *)
End[];(*"`diffEqDump`"*)


(* ::Input::Initialization:: *)
$ex;(*Protect[$ex];*)
Begin["Global`"]; (* for ODE variables *)
(*Unprotect[$ex];*)
(*$ex:=*)$ex=(*AssociationThread[Range@Length@#:>#]&@*)Association@MapIndexed[With[{i=First@#2},i:>($ex[i]=ReleaseHold@#)]&]@Thread@Hold@
{setupDiffEq[NDSolve[{\[FormalY]'[\[FormalT]]==\[FormalY][\[FormalT]],\[FormalY][0]==1},\[FormalY],{\[FormalT],0,2}],"title"->"NDSolve IVP(1)"],
setupDiffEq[DSolve[{\[FormalY]'[\[FormalT]]==\[FormalY][\[FormalT]],\[FormalY][0]==1},\[FormalY],{\[FormalT],0,2}],"title"->"DSolve IVP(1)"],
setupDiffEq[DSolve[{\[FormalY]'[\[FormalT]]==\[FormalY][\[FormalT]]-\[FormalY][\[FormalT]]^2},\[FormalY],{\[FormalT],0,2}],"title"->"DSolve General(1)"],
setupDiffEq[{\[FormalY]'[\[FormalT]]==\[FormalX][\[FormalT]],\[FormalX]'[\[FormalT]]==-\[FormalY][\[FormalT]]+\[FormalX][\[FormalT]],\[FormalX][0]==0,\[FormalY][0]==1},{\[FormalX],\[FormalY]},{\[FormalT],0,12},"title"->"User IVP(2)"],
setupDiffEq[{\[FormalY]''[\[FormalT]]==\[FormalY][\[FormalT]]-\[FormalY]'[\[FormalT]]},{\[FormalY]},{\[FormalT],0,10},"title"->"Linear General(2)"],
setupDiffEq[{(1-\[FormalT]^2)\[FormalX]''[\[FormalT]]-\[FormalT] \[FormalX]'[\[FormalT]]+\[FormalN]^2\[FormalX][\[FormalT]]==0},{\[FormalX]},{\[FormalT],-1,1},"title"->"Chebyshev T(2)","parameters"->{\[FormalN]},"defaultParameterValues"->{\[FormalN]->2}],
setupDiffEq[{2\[FormalX]'''[\[FormalT]]+ \[FormalX][\[FormalT]]\[FormalX]''[\[FormalT]]==0},{\[FormalX]},\[FormalT],"title"->"Blasius(3)"],
setupDiffEq[{\[FormalX]''[\[FormalT]]+Sin[\[FormalX][\[FormalT]]]==0},{\[FormalX]},\[FormalT],"title"->"Nonlinear Pendulum(2)"],
setupDiffEq[{\[FormalX]''[\[FormalT]]+\[FormalK] \[FormalX][\[FormalT]]==0},{\[FormalX]},\[FormalT],"title"->"Harmonic Oscillator(2)","parameters"->{\[FormalK]},"defaultParameterValues"->{\[FormalK]->4}],
setupDiffEq[{\[FormalX]''[\[FormalT]]+\[FormalA] \[FormalX]'[\[FormalT]]+\[FormalK] \[FormalX][\[FormalT]]==0},{\[FormalX]},\[FormalT],"title"->"Damped Harmonic Oscillator(2)","parameters"->{\[FormalA],\[FormalK]},"defaultParameterValues"->{\[FormalK]->5,\[FormalA]->2}],
setupDiffEq[{\[FormalX]''[\[FormalT]]+\[FormalA] Sign[\[FormalX]'[\[FormalT]]]+\[FormalK] \[FormalX][\[FormalT]]==0},{\[FormalX]},\[FormalT],"title"->"Harmonic Oscillator with Friction(2)","parameters"->{\[FormalA],\[FormalK]}],
setupDiffEq[{\[FormalX]''[\[FormalT]]-\[FormalT] \[FormalX][\[FormalT]]==0},{\[FormalX]},\[FormalT],"title"->"Airy(2)"],
setupDiffEq[{
\[FormalT](1-\[FormalT])\[FormalX]''[\[FormalT]]+(\[FormalCapitalC]-(\[FormalCapitalA]+\[FormalCapitalB]-1)\[FormalT])\[FormalX]'[\[FormalT]]-\[FormalCapitalA] \[FormalCapitalB] \[FormalX][\[FormalT]]==0},{\[FormalX]},{\[FormalT]},"title"->"Hypergeometric(2)","parameters"->{\[FormalCapitalA],\[FormalCapitalB],\[FormalCapitalC]}],
setupDiffEq[{(1-\[FormalT]^2)\[FormalX]'''[\[FormalT]]+\[FormalT] \[FormalX][\[FormalT]]\[FormalX]''[\[FormalT]]==(1-\[FormalT])},{\[FormalX]},\[FormalT],"title"->"Nonlinear Random(3)"],
setupDiffEq[{
\[FormalX]'[\[FormalT]]==1-4 \[FormalX][\[FormalT]]+\[FormalX][\[FormalT]]^2 \[FormalY][\[FormalT]],
\[FormalY]'[\[FormalT]]==3 \[FormalX][\[FormalT]]-\[FormalX][\[FormalT]]^2 \[FormalY][\[FormalT]],\[FormalX][0]==3/2,\[FormalY][0]==3},{\[FormalX],\[FormalY]},{\[FormalT],0,20},"title"->"Brusselator(2)"],
setupDiffEq[{
\[FormalX]'[\[FormalT]]==1+\[FormalX][\[FormalT]]^2 \[FormalY][\[FormalT]]-(\[FormalZ][\[FormalT]]+1)\[FormalX][\[FormalT]],
\[FormalY]'[\[FormalT]]==\[FormalX][\[FormalT]]\[FormalZ][\[FormalT]]-\[FormalX][\[FormalT]]^2 \[FormalY][\[FormalT]],
\[FormalZ]'[\[FormalT]]==-\[FormalX][\[FormalT]]\[FormalZ][\[FormalT]]+\[FormalCapitalA]},
{\[FormalX],\[FormalY],\[FormalZ]},{\[FormalT]},"title"->"Brusselator(3)"],(* ??? *)
setupDiffEq[{
\[FormalX]'[\[FormalT]]==\[FormalK][1]\[FormalCapitalA] \[FormalY][\[FormalT]]-\[FormalK][2]\[FormalX][\[FormalT]]\[FormalY][\[FormalT]]+\[FormalK][3]\[FormalCapitalA] \[FormalX][\[FormalT]]-2\[FormalK][4]\[FormalX][\[FormalT]]^2,
\[FormalY]'[\[FormalT]]==-\[FormalK][1]\[FormalCapitalA] \[FormalY][\[FormalT]]-\[FormalK][2]\[FormalX][\[FormalT]]\[FormalY][\[FormalT]]+1/2 \[FormalF] \[FormalK][5]\[FormalCapitalB] \[FormalZ][\[FormalT]],
\[FormalZ]'[\[FormalT]]==2\[FormalK][3]\[FormalCapitalA] \[FormalX][\[FormalT]]-\[FormalK][5]\[FormalCapitalB] \[FormalZ][\[FormalT]]},
{\[FormalX],\[FormalY],\[FormalZ]},{\[FormalT]},"title"->"Oregonator(3)","parameters"->{\[FormalCapitalA],\[FormalCapitalB],\[FormalK][1],\[FormalK][2],\[FormalK][3]}],
setupDiffEq[{
\[FormalX]''[\[FormalT]]== \[FormalY][\[FormalT]]-2\[FormalX][\[FormalT]],
\[FormalY]''[\[FormalT]]==\[FormalX][\[FormalT]]-2\[FormalY][\[FormalT]]},
{\[FormalX],\[FormalY]},{\[FormalT]},"title"->"Coupled oscillators (4)"],
setupDiffEq[DSolve[(\[FormalY][\[FormalT]]+\[FormalT]-1)*\[FormalY]'[\[FormalT]]-\[FormalY][\[FormalT]]+2 \[FormalT]+3==0,\[FormalY],\[FormalT]],"title"->"Implicit solution (1)"],
setupDiffEq[DSolve[\[FormalX]''[\[FormalT]] \[FormalX][\[FormalT]]-\[FormalX]'[\[FormalT]]^2+\[FormalX][\[FormalT]]^2+1==0,\[FormalX],\[FormalT]],"title"->"Inverse function and integrals (2)"],
setupDiffEq[DSolve[{3*\[FormalY][\[FormalT]]+2*\[FormalX]*\[FormalY][\[FormalT]]^2+(2*\[FormalT]+3*\[FormalT]^2*\[FormalY][\[FormalT]])*\[FormalY]'[\[FormalT]]==0,\[FormalY][1]==1/2},\[FormalY][\[FormalT]],\[FormalT]],"title"->"Root[] solution (1)"],
setupDiffEq[DSolve[{\[FormalX]'[\[FormalT]]+\[FormalX][\[FormalT]]==Sqrt[1+\[FormalT]^2],\[FormalX][0]==1},\[FormalX][\[FormalT]],\[FormalT]],"title"->"Integral solution (1)"],
setupDiffEq[DSolve[{\[FormalX]''[\[FormalT]]+2\[FormalX][\[FormalT]]==Sin[\[FormalT]],\[FormalX][0]==1,\[FormalX][2]==-1},\[FormalX][\[FormalT]],{\[FormalT],0,2}],"title"->"Linear BVP (2)"]
};
(*Protect[$ex];*)
End[]; (* "Global`" *)



Protect[diffEq];
EndPackage[]



